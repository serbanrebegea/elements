{"ast":null,"code":"export default function optimizeLayout(polygonPoints, zoneW, zoneH, lengths, tileWidth, margin) {\n  // Ray‑casting point‑in‑polygon\n  function pointInPolygon(x, y, vs) {\n    let inside = false;\n    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n      const xi = vs[i].x,\n        yi = vs[i].y;\n      const xj = vs[j].x,\n        yj = vs[j].y;\n      const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n      if (intersect) inside = !inside;\n    }\n    return inside;\n  }\n\n  // Distance from (px,py) to segment [(x1,y1)-(x2,y2)]\n  function pointToSegmentDist(px, py, x1, y1, x2, y2) {\n    const A = px - x1,\n      B = py - y1;\n    const C = x2 - x1,\n      D = y2 - y1;\n    const dot = A * C + B * D;\n    const len_sq = C * C + D * D;\n    let param = len_sq !== 0 ? dot / len_sq : -1;\n    let xx, yy;\n    if (param < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (param > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + param * C;\n      yy = y1 + param * D;\n    }\n    const dx = px - xx,\n      dy = py - yy;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n  const gridStep = 0.05; // 5 cm\n\n  // Check a candidate placement for polygon‑containment, margin and no overlap\n  function isPlacementValid(x, y, w, h) {\n    // corners\n    const corners = [{\n      x,\n      y\n    }, {\n      x: x + w,\n      y\n    }, {\n      x,\n      y: y + h\n    }, {\n      x: x + w,\n      y: y + h\n    }];\n    // 1) inside polygon\n    for (const c of corners) {\n      if (!pointInPolygon(c.x, c.y, polygonPoints)) return false;\n    }\n    // 2) at least margin from every edge\n    for (const c of corners) {\n      for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {\n        const p1 = polygonPoints[i];\n        const p2 = polygonPoints[j];\n        if (pointToSegmentDist(c.x, c.y, p1.x, p1.y, p2.x, p2.y) < margin) {\n          return false;\n        }\n      }\n    }\n    // 3) no overlap with existing tiles\n    for (const t of placements) {\n      if (!(x + w <= t.x || t.x + t.width <= x || y + h <= t.y || t.y + t.height <= y)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Greedy fill\n  for (const length of lengths) {\n    // two orientations: (length × tileWidth) and (tileWidth × length)\n    const oris = [{\n      w: length,\n      h: tileWidth,\n      length\n    }, {\n      w: tileWidth,\n      h: length,\n      length\n    }];\n    for (const {\n      w,\n      h,\n      length: L\n    } of oris) {\n      for (let x = 0; x + w <= zoneW; x += gridStep) {\n        for (let y = 0; y + h <= zoneH; y += gridStep) {\n          if (isPlacementValid(x, y, w, h)) {\n            placements.push({\n              x,\n              y,\n              width: w,\n              height: h,\n              length: L\n            });\n            counts[L]++;\n          }\n        }\n      }\n    }\n  }\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["optimizeLayout","polygonPoints","zoneW","zoneH","lengths","tileWidth","margin","pointInPolygon","x","y","vs","inside","i","j","length","xi","yi","xj","yj","intersect","pointToSegmentDist","px","py","x1","y1","x2","y2","A","B","C","D","dot","len_sq","param","xx","yy","dx","dy","Math","sqrt","placements","counts","gridStep","isPlacementValid","w","h","corners","c","p1","p2","t","width","height","oris","L","push"],"sources":["C:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["export default function optimizeLayout(\r\n  polygonPoints,\r\n  zoneW,\r\n  zoneH,\r\n  lengths,\r\n  tileWidth,\r\n  margin\r\n) {\r\n  // Ray‑casting point‑in‑polygon\r\n  function pointInPolygon(x, y, vs) {\r\n    let inside = false;\r\n    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\r\n      const xi = vs[i].x, yi = vs[i].y;\r\n      const xj = vs[j].x, yj = vs[j].y;\r\n      const intersect =\r\n        (yi > y) !== (yj > y) &&\r\n        x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\r\n      if (intersect) inside = !inside;\r\n    }\r\n    return inside;\r\n  }\r\n\r\n  // Distance from (px,py) to segment [(x1,y1)-(x2,y2)]\r\n  function pointToSegmentDist(px, py, x1, y1, x2, y2) {\r\n    const A = px - x1, B = py - y1;\r\n    const C = x2 - x1, D = y2 - y1;\r\n    const dot = A * C + B * D;\r\n    const len_sq = C * C + D * D;\r\n    let param = len_sq !== 0 ? dot / len_sq : -1;\r\n    let xx, yy;\r\n    if (param < 0) {\r\n      xx = x1; yy = y1;\r\n    } else if (param > 1) {\r\n      xx = x2; yy = y2;\r\n    } else {\r\n      xx = x1 + param * C;\r\n      yy = y1 + param * D;\r\n    }\r\n    const dx = px - xx, dy = py - yy;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  const placements = [];\r\n  const counts = { 4: 0, 2: 0, 1: 0 };\r\n  const gridStep = 0.05; // 5 cm\r\n\r\n  // Check a candidate placement for polygon‑containment, margin and no overlap\r\n  function isPlacementValid(x, y, w, h) {\r\n    // corners\r\n    const corners = [\r\n      { x, y },\r\n      { x: x + w, y },\r\n      { x, y: y + h },\r\n      { x: x + w, y: y + h }\r\n    ];\r\n    // 1) inside polygon\r\n    for (const c of corners) {\r\n      if (!pointInPolygon(c.x, c.y, polygonPoints)) return false;\r\n    }\r\n    // 2) at least margin from every edge\r\n    for (const c of corners) {\r\n      for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {\r\n        const p1 = polygonPoints[i];\r\n        const p2 = polygonPoints[j];\r\n        if (pointToSegmentDist(c.x, c.y, p1.x, p1.y, p2.x, p2.y) < margin) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    // 3) no overlap with existing tiles\r\n    for (const t of placements) {\r\n      if (\r\n        !(x + w <= t.x ||\r\n          t.x + t.width <= x ||\r\n          y + h <= t.y ||\r\n          t.y + t.height <= y)\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // Greedy fill\r\n  for (const length of lengths) {\r\n    // two orientations: (length × tileWidth) and (tileWidth × length)\r\n    const oris = [\r\n      { w: length, h: tileWidth, length },\r\n      { w: tileWidth, h: length, length }\r\n    ];\r\n    for (const { w, h, length: L } of oris) {\r\n      for (let x = 0; x + w <= zoneW; x += gridStep) {\r\n        for (let y = 0; y + h <= zoneH; y += gridStep) {\r\n          if (isPlacementValid(x, y, w, h)) {\r\n            placements.push({ x, y, width: w, height: h, length: L });\r\n            counts[L]++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}