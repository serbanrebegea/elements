{"ast":null,"code":"/**\r\n * Greedy edge‑to‑edge packer with exactly 207 mm clearance.\r\n *\r\n * @param {{x:number,y:number}[]} polygonPoints\r\n * @param {number[]} lengthsIn      – long‐side options [4,2,1]\r\n * @param {number} tileW            – short side in meters (1.26)\r\n * @param {number} margin           – required clearance (0.207)\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n * @param {'bottom-left'|'bottom-right'|'top-right'|'top-left'} startCorner\r\n * @returns {{placements:Array,counts:{4:number,2:number,1:number}}}\r\n */\nexport default function optimizeLayout(polygonPoints, lengthsIn, tileW, margin, orientation, startCorner) {\n  // --- Geometry helpers ---\n  function pointInPoly(x, y, vs) {\n    let inside = false;\n    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n      const xi = vs[i].x,\n        yi = vs[i].y;\n      const xj = vs[j].x,\n        yj = vs[j].y;\n      const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n      if (intersect) inside = !inside;\n    }\n    return inside;\n  }\n  function ptSegDist(px, py, x1, y1, x2, y2) {\n    const A = px - x1,\n      B = py - y1;\n    const C = x2 - x1,\n      D = y2 - y1;\n    const dot = A * C + B * D;\n    const len2 = C * C + D * D;\n    let t = len2 ? dot / len2 : -1,\n      xx,\n      yy;\n    if (t < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (t > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + t * C;\n      yy = y1 + t * D;\n    }\n    const dx = px - xx,\n      dy = py - yy;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  // Full validity check: inside, margin, no overlap\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n  function isValid(x, y, w, h) {\n    const corners = [{\n      x,\n      y\n    }, {\n      x: x + w,\n      y\n    }, {\n      x,\n      y: y + h\n    }, {\n      x: x + w,\n      y: y + h\n    }];\n    // 1) inside polygon\n    for (const c of corners) {\n      if (!pointInPoly(c.x, c.y, polygonPoints)) return false;\n    }\n    // 2) margin from every edge\n    for (const c of corners) {\n      for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {\n        const p1 = polygonPoints[i],\n          p2 = polygonPoints[j];\n        if (ptSegDist(c.x, c.y, p1.x, p1.y, p2.x, p2.y) < margin) {\n          return false;\n        }\n      }\n    }\n    // 3) no overlap\n    for (const t of placements) {\n      if (!(x + w <= t.x || t.x + t.width <= x || y + h <= t.y || t.y + t.height <= y)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // --- Prepare scan bounds & directions ---\n  const xs = polygonPoints.map(p => p.x),\n    ys = polygonPoints.map(p => p.y);\n  const minX = Math.min(...xs),\n    maxX = Math.max(...xs),\n    minY = Math.min(...ys),\n    maxY = Math.max(...ys);\n\n  // Determine X/Y direction from startCorner\n  const cornerMap = {\n    'bottom-left': {\n      xDir: +1,\n      yDir: +1\n    },\n    'bottom-right': {\n      xDir: -1,\n      yDir: +1\n    },\n    'top-right': {\n      xDir: -1,\n      yDir: -1\n    },\n    'top-left': {\n      xDir: +1,\n      yDir: -1\n    }\n  }[startCorner];\n  const {\n    xDir,\n    yDir\n  } = cornerMap;\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const minLen = lengths[lengths.length - 1];\n\n  // Starting & ending bounds for rows/columns\n  const yStart = yDir > 0 ? minY + margin : maxY - margin - tileW;\n  const yEnd = yDir > 0 ? maxY - margin - tileW : minY + margin;\n  const xStart = xDir > 0 ? minX + margin : maxX - margin;\n  const xEnd = xDir > 0 ? maxX - margin - minLen : minX + margin + minLen;\n  const yStep = tileW * yDir;\n  const xStep = minLen * xDir;\n\n  // --- Packing routines ---\n\n  function doHorizontal() {\n    for (let y = yStart; yDir > 0 ? y <= yEnd : y >= yEnd; y += yStep) {\n      let x = xStart;\n      while (xDir > 0 ? x <= xEnd : x >= xEnd) {\n        let placed = false;\n        for (const L of lengths) {\n          const px = xDir > 0 ? x : x - L;\n          if (isValid(px, y, L, tileW)) {\n            placements.push({\n              x: px,\n              y,\n              width: L,\n              height: tileW,\n              length: L\n            });\n            counts[L]++;\n            x += L * xDir;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) {\n          x += xStep;\n        }\n      }\n    }\n  }\n  function doVertical() {\n    for (let x = xStart; xDir > 0 ? x <= xEnd : x >= xEnd; x += yStep) {\n      let y = yStart;\n      while (yDir > 0 ? y <= yEnd : y >= yEnd) {\n        let placed = false;\n        for (const L of lengths) {\n          const py = yDir > 0 ? y : y - L;\n          if (isValid(x, py, tileW, L)) {\n            placements.push({\n              x,\n              y: py,\n              width: tileW,\n              height: L,\n              length: L\n            });\n            counts[L]++;\n            y += L * yDir;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) {\n          y += tileW * yDir;\n        }\n      }\n    }\n  }\n  if (orientation === 'both' || orientation === 'horizontal') {\n    doHorizontal();\n  }\n  if (orientation === 'both' || orientation === 'vertical') {\n    doVertical();\n  }\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["optimizeLayout","polygonPoints","lengthsIn","tileW","margin","orientation","startCorner","pointInPoly","x","y","vs","inside","i","j","length","xi","yi","xj","yj","intersect","ptSegDist","px","py","x1","y1","x2","y2","A","B","C","D","dot","len2","t","xx","yy","dx","dy","Math","sqrt","placements","counts","isValid","w","h","corners","c","p1","p2","width","height","xs","map","p","ys","minX","min","maxX","max","minY","maxY","cornerMap","xDir","yDir","lengths","sort","a","b","minLen","yStart","yEnd","xStart","xEnd","yStep","xStep","doHorizontal","placed","L","push","doVertical"],"sources":["c:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["/**\r\n * Greedy edge‑to‑edge packer with exactly 207 mm clearance.\r\n *\r\n * @param {{x:number,y:number}[]} polygonPoints\r\n * @param {number[]} lengthsIn      – long‐side options [4,2,1]\r\n * @param {number} tileW            – short side in meters (1.26)\r\n * @param {number} margin           – required clearance (0.207)\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n * @param {'bottom-left'|'bottom-right'|'top-right'|'top-left'} startCorner\r\n * @returns {{placements:Array,counts:{4:number,2:number,1:number}}}\r\n */\r\nexport default function optimizeLayout(\r\n  polygonPoints,\r\n  lengthsIn,\r\n  tileW,\r\n  margin,\r\n  orientation,\r\n  startCorner\r\n) {\r\n  // --- Geometry helpers ---\r\n  function pointInPoly(x, y, vs) {\r\n    let inside = false;\r\n    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\r\n      const xi = vs[i].x, yi = vs[i].y;\r\n      const xj = vs[j].x, yj = vs[j].y;\r\n      const intersect =\r\n        (yi > y) !== (yj > y) &&\r\n        x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\r\n      if (intersect) inside = !inside;\r\n    }\r\n    return inside;\r\n  }\r\n\r\n  function ptSegDist(px, py, x1, y1, x2, y2) {\r\n    const A = px - x1, B = py - y1;\r\n    const C = x2 - x1, D = y2 - y1;\r\n    const dot = A*C + B*D;\r\n    const len2 = C*C + D*D;\r\n    let t = len2 ? dot/len2 : -1, xx, yy;\r\n    if (t < 0)      { xx = x1; yy = y1; }\r\n    else if (t > 1) { xx = x2; yy = y2; }\r\n    else {\r\n      xx = x1 + t*C;\r\n      yy = y1 + t*D;\r\n    }\r\n    const dx = px - xx, dy = py - yy;\r\n    return Math.sqrt(dx*dx + dy*dy);\r\n  }\r\n\r\n  // Full validity check: inside, margin, no overlap\r\n  const placements = [];\r\n  const counts = {4:0,2:0,1:0};\r\n  function isValid(x, y, w, h) {\r\n    const corners = [\r\n      {x,y}, {x:x+w,y},\r\n      {x,y:y+h}, {x:x+w,y:y+h}\r\n    ];\r\n    // 1) inside polygon\r\n    for (const c of corners) {\r\n      if (!pointInPoly(c.x, c.y, polygonPoints)) return false;\r\n    }\r\n    // 2) margin from every edge\r\n    for (const c of corners) {\r\n      for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {\r\n        const p1 = polygonPoints[i], p2 = polygonPoints[j];\r\n        if (ptSegDist(c.x, c.y, p1.x, p1.y, p2.x, p2.y) < margin) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    // 3) no overlap\r\n    for (const t of placements) {\r\n      if (!(\r\n        x + w <= t.x ||\r\n        t.x + t.width <= x ||\r\n        y + h <= t.y ||\r\n        t.y + t.height <= y\r\n      )) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // --- Prepare scan bounds & directions ---\r\n  const xs = polygonPoints.map(p => p.x),\r\n        ys = polygonPoints.map(p => p.y);\r\n  const minX = Math.min(...xs),\r\n        maxX = Math.max(...xs),\r\n        minY = Math.min(...ys),\r\n        maxY = Math.max(...ys);\r\n\r\n  // Determine X/Y direction from startCorner\r\n  const cornerMap = {\r\n    'bottom-left':  { xDir: +1, yDir: +1 },\r\n    'bottom-right': { xDir: -1, yDir: +1 },\r\n    'top-right':    { xDir: -1, yDir: -1 },\r\n    'top-left':     { xDir: +1, yDir: -1 }\r\n  }[startCorner];\r\n  const { xDir, yDir } = cornerMap;\r\n\r\n  const lengths = [...lengthsIn].sort((a,b)=>b-a);\r\n  const minLen = lengths[lengths.length - 1];\r\n\r\n  // Starting & ending bounds for rows/columns\r\n  const yStart = yDir > 0\r\n    ? minY + margin\r\n    : maxY - margin - tileW;\r\n  const yEnd   = yDir > 0\r\n    ? maxY - margin - tileW\r\n    : minY + margin;\r\n  const xStart = xDir > 0\r\n    ? minX + margin\r\n    : maxX - margin;\r\n  const xEnd   = xDir > 0\r\n    ? maxX - margin - minLen\r\n    : minX + margin + minLen;\r\n\r\n  const yStep = tileW * yDir;\r\n  const xStep = minLen * xDir;\r\n\r\n  // --- Packing routines ---\r\n\r\n  function doHorizontal() {\r\n    for (let y = yStart; (yDir>0 ? y <= yEnd : y >= yEnd); y += yStep) {\r\n      let x = xStart;\r\n      while (xDir>0 ? x <= xEnd : x >= xEnd) {\r\n        let placed = false;\r\n        for (const L of lengths) {\r\n          const px = xDir>0 ? x : x - L;\r\n          if (isValid(px, y, L, tileW)) {\r\n            placements.push({ x: px, y, width: L, height: tileW, length: L });\r\n            counts[L]++;\r\n            x += L * xDir;\r\n            placed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!placed) {\r\n          x += xStep;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function doVertical() {\r\n    for (let x = xStart; (xDir>0 ? x <= xEnd : x >= xEnd); x += yStep) {\r\n      let y = yStart;\r\n      while (yDir>0 ? y <= yEnd : y >= yEnd) {\r\n        let placed = false;\r\n        for (const L of lengths) {\r\n          const py = yDir>0 ? y : y - L;\r\n          if (isValid(x, py, tileW, L)) {\r\n            placements.push({ x, y: py, width: tileW, height: L, length: L });\r\n            counts[L]++;\r\n            y += L * yDir;\r\n            placed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!placed) {\r\n          y += tileW * yDir;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (orientation === 'both' || orientation === 'horizontal') {\r\n    doHorizontal();\r\n  }\r\n  if (orientation === 'both' || orientation === 'vertical') {\r\n    doVertical();\r\n  }\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}