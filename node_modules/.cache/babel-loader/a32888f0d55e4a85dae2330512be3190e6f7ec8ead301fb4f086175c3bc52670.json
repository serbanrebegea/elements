{"ast":null,"code":"// src/utils/optimizer.js\n\nimport * as turf from '@turf/turf';\n\n/**\r\n * @param {Array<{x:number,y:number}>} polygonPoints  – your room polygon vertices in meters\r\n * @param {number} zoneW   – overall bounding‑box width (m)\r\n * @param {number} zoneH   – overall bounding‑box height (m)\r\n * @param {number[]} lengthsIn – tile lengths to try, e.g. [4,2,1]\r\n * @param {number} tileW   – tile short side (m), e.g. 1.26\r\n * @param {number} margin  – required clearance from walls (m), e.g. 0.207\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n *\r\n * @returns {{ placements: Array<{x,y,width,height,length}>, counts: {4:number,2:number,1:number} }}\r\n */\nexport default function optimizeLayout(polygonPoints, zoneW, zoneH, lengthsIn, tileW, margin, orientation) {\n  // 1) Build your room polygon and shrink it inward by `margin`\n  const coords = polygonPoints.map(p => [p.x, p.y]);\n  coords.push(coords[0]); // close the ring\n  const roomPoly = turf.polygon([coords]);\n  // inward buffer: shrinks by `margin`\n  const inner = turf.buffer(roomPoly, -margin, {\n    units: 'meters'\n  });\n  if (!inner || !inner.geometry) {\n    // too small to fit any tile\n    return {\n      placements: [],\n      counts: {\n        4: 0,\n        2: 0,\n        1: 0\n      }\n    };\n  }\n\n  // get bounding box of allowed region\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\n\n  // sort lengths descending so we always try largest first\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // helper: test if a w×h tile at (x,y) lies entirely inside `inner`\n  function fitsInInner(x, y, w, h) {\n    const rect = turf.polygon([[[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]]]);\n    return turf.booleanContains(inner, rect);\n  }\n\n  // helper: compute the horizontal segments of `inner` within [y, y+tileW)\n  function getHorizontalSegments(y) {\n    const strip = turf.bboxPolygon([minX, y, maxX, y + tileW]);\n    const clipped = turf.intersect(inner, strip);\n    if (!clipped) return [];\n    const polys = clipped.geometry.type === 'Polygon' ? [clipped.geometry.coordinates] : clipped.geometry.coordinates;\n    // each outer ring → [xMin, xMax]\n    return polys.map(ring => {\n      const xs = ring[0].map(pt => pt[0]);\n      return [Math.min(...xs), Math.max(...xs)];\n    });\n  }\n\n  // helper: compute the vertical segments of `inner` within [x, x+tileW)\n  function getVerticalSegments(x) {\n    const strip = turf.bboxPolygon([x, minY, x + tileW, maxY]);\n    const clipped = turf.intersect(inner, strip);\n    if (!clipped) return [];\n    const polys = clipped.geometry.type === 'Polygon' ? [clipped.geometry.coordinates] : clipped.geometry.coordinates;\n    // each outer ring → [yMin, yMax]\n    return polys.map(ring => {\n      const ys = ring[0].map(pt => pt[1]);\n      return [Math.min(...ys), Math.max(...ys)];\n    });\n  }\n\n  // 2) Pack horizontal‑long tiles: fill each horizontal strip\n  function doHorizontal() {\n    // iterate strips from bottom to top\n    for (let y = minY; y <= maxY - tileW + 1e-6; y += tileW) {\n      const segments = getHorizontalSegments(y);\n      segments.forEach(([xMin, xMax]) => {\n        let x = xMin;\n        // walk along this segment, greedy L→small\n        while (x <= xMax - lengths[lengths.length - 1] + 1e-6) {\n          let placed = false;\n          for (const L of lengths) {\n            if (x + L <= xMax + 1e-6 && fitsInInner(x, y, L, tileW)) {\n              placements.push({\n                x,\n                y,\n                width: L,\n                height: tileW,\n                length: L\n              });\n              counts[L]++;\n              x += L;\n              placed = true;\n              break;\n            }\n          }\n          if (!placed) {\n            // if the gap here is > tileW (i.e. > needed clearance), we still try to fill\n            x += tileW;\n          }\n        }\n      });\n    }\n  }\n\n  // 3) Pack vertical‑long tiles: fill each vertical strip\n  function doVertical() {\n    // iterate strips from left to right\n    for (let x = minX; x <= maxX - tileW + 1e-6; x += tileW) {\n      const segments = getVerticalSegments(x);\n      segments.forEach(([yMin, yMax]) => {\n        let y = yMin;\n        while (y <= yMax - lengths[lengths.length - 1] + 1e-6) {\n          let placed = false;\n          for (const L of lengths) {\n            if (y + L <= yMax + 1e-6 && fitsInInner(x, y, tileW, L)) {\n              placements.push({\n                x,\n                y,\n                width: tileW,\n                height: L,\n                length: L\n              });\n              counts[L]++;\n              y += L;\n              placed = true;\n              break;\n            }\n          }\n          if (!placed) {\n            y += tileW;\n          }\n        }\n      });\n    }\n  }\n  if (orientation === 'both' || orientation === 'horizontal') {\n    doHorizontal();\n  }\n  if (orientation === 'both' || orientation === 'vertical') {\n    doVertical();\n  }\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["turf","optimizeLayout","polygonPoints","zoneW","zoneH","lengthsIn","tileW","margin","orientation","coords","map","p","x","y","push","roomPoly","polygon","inner","buffer","units","geometry","placements","counts","minX","minY","maxX","maxY","bbox","lengths","sort","a","b","fitsInInner","w","h","rect","booleanContains","getHorizontalSegments","strip","bboxPolygon","clipped","intersect","polys","type","coordinates","ring","xs","pt","Math","min","max","getVerticalSegments","ys","doHorizontal","segments","forEach","xMin","xMax","length","placed","L","width","height","doVertical","yMin","yMax"],"sources":["c:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["// src/utils/optimizer.js\r\n\r\nimport * as turf from '@turf/turf';\r\n\r\n/**\r\n * @param {Array<{x:number,y:number}>} polygonPoints  – your room polygon vertices in meters\r\n * @param {number} zoneW   – overall bounding‑box width (m)\r\n * @param {number} zoneH   – overall bounding‑box height (m)\r\n * @param {number[]} lengthsIn – tile lengths to try, e.g. [4,2,1]\r\n * @param {number} tileW   – tile short side (m), e.g. 1.26\r\n * @param {number} margin  – required clearance from walls (m), e.g. 0.207\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n *\r\n * @returns {{ placements: Array<{x,y,width,height,length}>, counts: {4:number,2:number,1:number} }}\r\n */\r\nexport default function optimizeLayout(\r\n  polygonPoints,\r\n  zoneW,\r\n  zoneH,\r\n  lengthsIn,\r\n  tileW,\r\n  margin,\r\n  orientation\r\n) {\r\n  // 1) Build your room polygon and shrink it inward by `margin`\r\n  const coords = polygonPoints.map(p => [p.x, p.y]);\r\n  coords.push(coords[0]); // close the ring\r\n  const roomPoly = turf.polygon([coords]);\r\n  // inward buffer: shrinks by `margin`\r\n  const inner = turf.buffer(roomPoly, -margin, { units: 'meters' });\r\n  if (!inner || !inner.geometry) {\r\n    // too small to fit any tile\r\n    return { placements: [], counts: {4:0,2:0,1:0} };\r\n  }\r\n\r\n  // get bounding box of allowed region\r\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\r\n\r\n  // sort lengths descending so we always try largest first\r\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\r\n\r\n  const placements = [];\r\n  const counts = {4: 0, 2: 0, 1: 0};\r\n\r\n  // helper: test if a w×h tile at (x,y) lies entirely inside `inner`\r\n  function fitsInInner(x, y, w, h) {\r\n    const rect = turf.polygon([[\r\n      [x,     y],\r\n      [x + w, y],\r\n      [x + w, y + h],\r\n      [x,     y + h],\r\n      [x,     y]\r\n    ]]);\r\n    return turf.booleanContains(inner, rect);\r\n  }\r\n\r\n  // helper: compute the horizontal segments of `inner` within [y, y+tileW)\r\n  function getHorizontalSegments(y) {\r\n    const strip = turf.bboxPolygon([minX, y, maxX, y + tileW]);\r\n    const clipped = turf.intersect(inner, strip);\r\n    if (!clipped) return [];\r\n    const polys = clipped.geometry.type === 'Polygon'\r\n      ? [clipped.geometry.coordinates]\r\n      : clipped.geometry.coordinates;\r\n    // each outer ring → [xMin, xMax]\r\n    return polys.map(ring => {\r\n      const xs = ring[0].map(pt => pt[0]);\r\n      return [Math.min(...xs), Math.max(...xs)];\r\n    });\r\n  }\r\n\r\n  // helper: compute the vertical segments of `inner` within [x, x+tileW)\r\n  function getVerticalSegments(x) {\r\n    const strip = turf.bboxPolygon([x, minY, x + tileW, maxY]);\r\n    const clipped = turf.intersect(inner, strip);\r\n    if (!clipped) return [];\r\n    const polys = clipped.geometry.type === 'Polygon'\r\n      ? [clipped.geometry.coordinates]\r\n      : clipped.geometry.coordinates;\r\n    // each outer ring → [yMin, yMax]\r\n    return polys.map(ring => {\r\n      const ys = ring[0].map(pt => pt[1]);\r\n      return [Math.min(...ys), Math.max(...ys)];\r\n    });\r\n  }\r\n\r\n  // 2) Pack horizontal‑long tiles: fill each horizontal strip\r\n  function doHorizontal() {\r\n    // iterate strips from bottom to top\r\n    for (let y = minY; y <= maxY - tileW + 1e-6; y += tileW) {\r\n      const segments = getHorizontalSegments(y);\r\n      segments.forEach(([xMin, xMax]) => {\r\n        let x = xMin;\r\n        // walk along this segment, greedy L→small\r\n        while (x <= xMax - lengths[lengths.length - 1] + 1e-6) {\r\n          let placed = false;\r\n          for (const L of lengths) {\r\n            if (x + L <= xMax + 1e-6 && fitsInInner(x, y, L, tileW)) {\r\n              placements.push({ x, y, width: L, height: tileW, length: L });\r\n              counts[L]++;\r\n              x += L;\r\n              placed = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!placed) {\r\n            // if the gap here is > tileW (i.e. > needed clearance), we still try to fill\r\n            x += tileW;\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // 3) Pack vertical‑long tiles: fill each vertical strip\r\n  function doVertical() {\r\n    // iterate strips from left to right\r\n    for (let x = minX; x <= maxX - tileW + 1e-6; x += tileW) {\r\n      const segments = getVerticalSegments(x);\r\n      segments.forEach(([yMin, yMax]) => {\r\n        let y = yMin;\r\n        while (y <= yMax - lengths[lengths.length - 1] + 1e-6) {\r\n          let placed = false;\r\n          for (const L of lengths) {\r\n            if (y + L <= yMax + 1e-6 && fitsInInner(x, y, tileW, L)) {\r\n              placements.push({ x, y, width: tileW, height: L, length: L });\r\n              counts[L]++;\r\n              y += L;\r\n              placed = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!placed) {\r\n            y += tileW;\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  if (orientation === 'both' || orientation === 'horizontal') {\r\n    doHorizontal();\r\n  }\r\n  if (orientation === 'both' || orientation === 'vertical') {\r\n    doVertical();\r\n  }\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}