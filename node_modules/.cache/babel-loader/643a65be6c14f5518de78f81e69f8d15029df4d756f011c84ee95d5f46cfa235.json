{"ast":null,"code":"// src/utils/optimizer.js\n\n// Greedy, edge‑to‑edge packer with proper fallback to smaller tiles\nexport default function optimizeLayout(polygonPoints,\n// [{x,y},…] in meters\nzoneW,\n// room bounding‑box width in m\nzoneH,\n// room bounding‑box height in m\nlengthsIn,\n// e.g. [4,2,1]\ntileW,\n// tile width (short side) in m, e.g. 1.26\nmargin,\n// margin from room edges in m, e.g. 0.207\norientation // 'both' | 'horizontal' | 'vertical'\n) {\n  // ---- Geometry helpers ----\n\n  // point-in-polygon (ray‑cast)\n  function pointInPoly(x, y, vs) {\n    let inside = false;\n    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n      const xi = vs[i].x,\n        yi = vs[i].y;\n      const xj = vs[j].x,\n        yj = vs[j].y;\n      const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n      if (intersect) inside = !inside;\n    }\n    return inside;\n  }\n\n  // distance from point to segment\n  function ptSegDist(px, py, x1, y1, x2, y2) {\n    const A = px - x1,\n      B = py - y1;\n    const C = x2 - x1,\n      D = y2 - y1;\n    const dot = A * C + B * D;\n    const len2 = C * C + D * D;\n    let t = len2 !== 0 ? dot / len2 : -1;\n    let xx, yy;\n    if (t < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (t > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + t * C;\n      yy = y1 + t * D;\n    }\n    const dx = px - xx,\n      dy = py - yy;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  // ---- Setup ----\n\n  // ensure we always try big→small\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // ---- Validity check ----\n  // Checks that a w×h tile at (x,y) is:\n  // 1) fully inside the room polygon\n  // 2) at least `margin` from every room edge\n  // 3) not overlapping any already‑placed tile\n  function isValid(x, y, w, h) {\n    // corners of this candidate tile\n    const corners = [{\n      x: x,\n      y: y\n    }, {\n      x: x + w,\n      y: y\n    }, {\n      x: x,\n      y: y + h\n    }, {\n      x: x + w,\n      y: y + h\n    }];\n\n    // 1) each corner must lie inside the room polygon\n    for (const c of corners) {\n      if (!pointInPoly(c.x, c.y, polygonPoints)) return false;\n    }\n\n    // 2) each corner must be at least `margin` from every room edge\n    for (const c of corners) {\n      for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {\n        const p1 = polygonPoints[i];\n        const p2 = polygonPoints[j];\n        if (ptSegDist(c.x, c.y, p1.x, p1.y, p2.x, p2.y) < margin) {\n          return false;\n        }\n      }\n    }\n\n    // 3) must not overlap any existing tile\n    for (const t of placements) {\n      if (!(x + w <= t.x || t.x + t.width <= x || y + h <= t.y || t.y + t.height <= y)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // ---- Packing routines ----\n\n  // Pack horizontal‑long tiles in strips of height `tileW`\n  function doHorizontal() {\n    const startY = margin;\n    const rows = Math.floor((zoneH - 2 * margin) / tileW);\n    for (let r = 0; r < rows; r++) {\n      const y = startY + r * tileW;\n      let x = margin;\n      while (x < zoneW - margin - 1e-6) {\n        let placed = false;\n        for (const L of lengths) {\n          // only try L if it geometrically fits in the remaining width\n          if (x + L <= zoneW - margin + 1e-6) {\n            if (isValid(x, y, L, tileW)) {\n              placements.push({\n                x,\n                y,\n                width: L,\n                height: tileW,\n                length: L\n              });\n              counts[L]++;\n              x += L; // advance by the length placed\n              placed = true;\n              break;\n            }\n          }\n        }\n        if (!placed) {\n          // no tile fit here → skip ahead by one strip\n          x += tileW;\n        }\n      }\n    }\n  }\n\n  // Pack vertical‑long tiles in strips of width `tileW`\n  function doVertical() {\n    const startX = margin;\n    const cols = Math.floor((zoneW - 2 * margin) / tileW);\n    for (let c = 0; c < cols; c++) {\n      const x = startX + c * tileW;\n      let y = margin;\n      while (y < zoneH - margin - 1e-6) {\n        let placed = false;\n        for (const L of lengths) {\n          if (y + L <= zoneH - margin + 1e-6) {\n            if (isValid(x, y, tileW, L)) {\n              placements.push({\n                x,\n                y,\n                width: tileW,\n                height: L,\n                length: L\n              });\n              counts[L]++;\n              y += L;\n              placed = true;\n              break;\n            }\n          }\n        }\n        if (!placed) {\n          y += tileW;\n        }\n      }\n    }\n  }\n\n  // Run the chosen orientation(s)\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\n  if (orientation === 'both' || orientation === 'vertical') doVertical();\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["optimizeLayout","polygonPoints","zoneW","zoneH","lengthsIn","tileW","margin","orientation","pointInPoly","x","y","vs","inside","i","j","length","xi","yi","xj","yj","intersect","ptSegDist","px","py","x1","y1","x2","y2","A","B","C","D","dot","len2","t","xx","yy","dx","dy","Math","sqrt","lengths","sort","a","b","placements","counts","isValid","w","h","corners","c","p1","p2","width","height","doHorizontal","startY","rows","floor","r","placed","L","push","doVertical","startX","cols"],"sources":["c:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["// src/utils/optimizer.js\r\n\r\n// Greedy, edge‑to‑edge packer with proper fallback to smaller tiles\r\nexport default function optimizeLayout(\r\n  polygonPoints,  // [{x,y},…] in meters\r\n  zoneW,          // room bounding‑box width in m\r\n  zoneH,          // room bounding‑box height in m\r\n  lengthsIn,      // e.g. [4,2,1]\r\n  tileW,          // tile width (short side) in m, e.g. 1.26\r\n  margin,         // margin from room edges in m, e.g. 0.207\r\n  orientation     // 'both' | 'horizontal' | 'vertical'\r\n) {\r\n  // ---- Geometry helpers ----\r\n\r\n  // point-in-polygon (ray‑cast)\r\n  function pointInPoly(x, y, vs) {\r\n    let inside = false;\r\n    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\r\n      const xi = vs[i].x, yi = vs[i].y;\r\n      const xj = vs[j].x, yj = vs[j].y;\r\n      const intersect =\r\n        (yi > y) !== (yj > y) &&\r\n        x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\r\n      if (intersect) inside = !inside;\r\n    }\r\n    return inside;\r\n  }\r\n\r\n  // distance from point to segment\r\n  function ptSegDist(px, py, x1, y1, x2, y2) {\r\n    const A = px - x1, B = py - y1;\r\n    const C = x2 - x1, D = y2 - y1;\r\n    const dot = A * C + B * D;\r\n    const len2 = C * C + D * D;\r\n    let t = len2 !== 0 ? dot / len2 : -1;\r\n    let xx, yy;\r\n    if (t < 0) {\r\n      xx = x1; yy = y1;\r\n    } else if (t > 1) {\r\n      xx = x2; yy = y2;\r\n    } else {\r\n      xx = x1 + t * C;\r\n      yy = y1 + t * D;\r\n    }\r\n    const dx = px - xx, dy = py - yy;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  // ---- Setup ----\r\n\r\n  // ensure we always try big→small\r\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\r\n\r\n  const placements = [];\r\n  const counts = { 4: 0, 2: 0, 1: 0 };\r\n\r\n  // ---- Validity check ----\r\n  // Checks that a w×h tile at (x,y) is:\r\n  // 1) fully inside the room polygon\r\n  // 2) at least `margin` from every room edge\r\n  // 3) not overlapping any already‑placed tile\r\n  function isValid(x, y, w, h) {\r\n    // corners of this candidate tile\r\n    const corners = [\r\n      { x: x,     y: y     },\r\n      { x: x + w, y: y     },\r\n      { x: x,     y: y + h },\r\n      { x: x + w, y: y + h }\r\n    ];\r\n\r\n    // 1) each corner must lie inside the room polygon\r\n    for (const c of corners) {\r\n      if (!pointInPoly(c.x, c.y, polygonPoints)) return false;\r\n    }\r\n\r\n    // 2) each corner must be at least `margin` from every room edge\r\n    for (const c of corners) {\r\n      for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {\r\n        const p1 = polygonPoints[i];\r\n        const p2 = polygonPoints[j];\r\n        if (ptSegDist(c.x, c.y, p1.x, p1.y, p2.x, p2.y) < margin) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    // 3) must not overlap any existing tile\r\n    for (const t of placements) {\r\n      if (\r\n        !(x + w <= t.x ||\r\n          t.x + t.width <= x ||\r\n          y + h <= t.y ||\r\n          t.y + t.height <= y)\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // ---- Packing routines ----\r\n\r\n  // Pack horizontal‑long tiles in strips of height `tileW`\r\n  function doHorizontal() {\r\n    const startY = margin;\r\n    const rows = Math.floor((zoneH - 2 * margin) / tileW);\r\n\r\n    for (let r = 0; r < rows; r++) {\r\n      const y = startY + r * tileW;\r\n      let x = margin;\r\n\r\n      while (x < zoneW - margin - 1e-6) {\r\n        let placed = false;\r\n\r\n        for (const L of lengths) {\r\n          // only try L if it geometrically fits in the remaining width\r\n          if (x + L <= zoneW - margin + 1e-6) {\r\n            if (isValid(x, y, L, tileW)) {\r\n              placements.push({ x, y, width: L, height: tileW, length: L });\r\n              counts[L]++;\r\n              x += L;     // advance by the length placed\r\n              placed = true;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (!placed) {\r\n          // no tile fit here → skip ahead by one strip\r\n          x += tileW;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Pack vertical‑long tiles in strips of width `tileW`\r\n  function doVertical() {\r\n    const startX = margin;\r\n    const cols = Math.floor((zoneW - 2 * margin) / tileW);\r\n\r\n    for (let c = 0; c < cols; c++) {\r\n      const x = startX + c * tileW;\r\n      let y = margin;\r\n\r\n      while (y < zoneH - margin - 1e-6) {\r\n        let placed = false;\r\n\r\n        for (const L of lengths) {\r\n          if (y + L <= zoneH - margin + 1e-6) {\r\n            if (isValid(x, y, tileW, L)) {\r\n              placements.push({ x, y, width: tileW, height: L, length: L });\r\n              counts[L]++;\r\n              y += L;\r\n              placed = true;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (!placed) {\r\n          y += tileW;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Run the chosen orientation(s)\r\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\r\n  if (orientation === 'both' || orientation === 'vertical')   doVertical();\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}