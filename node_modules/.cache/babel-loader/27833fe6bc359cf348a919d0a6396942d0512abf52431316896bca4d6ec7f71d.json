{"ast":null,"code":"// src/utils/optimizer.js\n\n// Greedy, edge‑to‑edge packer with proper fallback to smaller tiles\nexport default function optimizeLayout(polygonPoints, zoneW, zoneH, lengthsIn,\n// e.g. [4,2,1]\ntileW,\n// e.g. 1.26\nmargin,\n// e.g. 0.207\norientation // 'both'|'horizontal'|'vertical'\n) {\n  // point‑in‑polygon (ray‑cast)\n  function pointInPoly(x, y, vs) {/* unchanged… */}\n  // point‑to‑segment distance\n  function ptSegDist(px, py, x1, y1, x2, y2) {/* unchanged… */}\n\n  // ensure we try big→small\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // full validity check (inside poly, margin, no overlap)\n  function isValid(x, y, w, h) {/* unchanged from before… */}\n\n  // HORIZONTAL packing\n  function doHorizontal() {\n    const startY = margin;\n    const rows = Math.floor((zoneH - 2 * margin) / tileW);\n    for (let r = 0; r < rows; r++) {\n      const y = startY + r * tileW;\n      let x = margin;\n      // walk across the row\n      while (x < zoneW - margin - 1e-6) {\n        let placed = false;\n        for (const L of lengths) {\n          // only try this L if it geometrically fits in the remaining width\n          if (x + L <= zoneW - margin + 1e-6) {\n            if (isValid(x, y, L, tileW)) {\n              placements.push({\n                x,\n                y,\n                width: L,\n                height: tileW,\n                length: L\n              });\n              counts[L]++;\n              x += L; // advance by the length we placed\n              placed = true;\n              break; // done with this (x,y), go to next x\n            }\n          }\n        }\n        if (!placed) {\n          // no tile fit at (x,y) — skip forward by one tile‑width\n          x += tileW;\n        }\n      }\n    }\n  }\n\n  // VERTICAL packing\n  function doVertical() {\n    const startX = margin;\n    const cols = Math.floor((zoneW - 2 * margin) / tileW);\n    for (let c = 0; c < cols; c++) {\n      const x = startX + c * tileW;\n      let y = margin;\n      while (y < zoneH - margin - 1e-6) {\n        let placed = false;\n        for (const L of lengths) {\n          if (y + L <= zoneH - margin + 1e-6) {\n            if (isValid(x, y, tileW, L)) {\n              placements.push({\n                x,\n                y,\n                width: tileW,\n                height: L,\n                length: L\n              });\n              counts[L]++;\n              y += L;\n              placed = true;\n              break;\n            }\n          }\n        }\n        if (!placed) {\n          y += tileW;\n        }\n      }\n    }\n  }\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\n  if (orientation === 'both' || orientation === 'vertical') doVertical();\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["optimizeLayout","polygonPoints","zoneW","zoneH","lengthsIn","tileW","margin","orientation","pointInPoly","x","y","vs","ptSegDist","px","py","x1","y1","x2","y2","lengths","sort","a","b","placements","counts","isValid","w","h","doHorizontal","startY","rows","Math","floor","r","placed","L","push","width","height","length","doVertical","startX","cols","c"],"sources":["c:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["// src/utils/optimizer.js\r\n\r\n// Greedy, edge‑to‑edge packer with proper fallback to smaller tiles\r\nexport default function optimizeLayout(\r\n  polygonPoints,\r\n  zoneW,\r\n  zoneH,\r\n  lengthsIn,    // e.g. [4,2,1]\r\n  tileW,        // e.g. 1.26\r\n  margin,       // e.g. 0.207\r\n  orientation   // 'both'|'horizontal'|'vertical'\r\n) {\r\n  // point‑in‑polygon (ray‑cast)\r\n  function pointInPoly(x,y,vs){ /* unchanged… */ }\r\n  // point‑to‑segment distance\r\n  function ptSegDist(px,py,x1,y1,x2,y2){ /* unchanged… */ }\r\n\r\n  // ensure we try big→small\r\n  const lengths = [...lengthsIn].sort((a,b)=>b-a);\r\n\r\n  const placements = [];\r\n  const counts = {4:0,2:0,1:0};\r\n\r\n  // full validity check (inside poly, margin, no overlap)\r\n  function isValid(x,y,w,h){ /* unchanged from before… */ }\r\n\r\n  // HORIZONTAL packing\r\n  function doHorizontal(){\r\n    const startY = margin;\r\n    const rows = Math.floor((zoneH - 2*margin)/tileW);\r\n    for(let r=0; r<rows; r++){\r\n      const y = startY + r*tileW;\r\n      let x = margin;\r\n      // walk across the row\r\n      while(x < zoneW - margin - 1e-6){\r\n        let placed = false;\r\n        for(const L of lengths){\r\n          // only try this L if it geometrically fits in the remaining width\r\n          if(x + L <= zoneW - margin + 1e-6){\r\n            if(isValid(x,y,L,tileW)){\r\n              placements.push({ x,y, width:L, height:tileW, length:L });\r\n              counts[L]++;\r\n              x += L;      // advance by the length we placed\r\n              placed = true;\r\n              break;       // done with this (x,y), go to next x\r\n            }\r\n          }\r\n        }\r\n        if(!placed){\r\n          // no tile fit at (x,y) — skip forward by one tile‑width\r\n          x += tileW;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // VERTICAL packing\r\n  function doVertical(){\r\n    const startX = margin;\r\n    const cols = Math.floor((zoneW - 2*margin)/tileW);\r\n    for(let c=0; c<cols; c++){\r\n      const x = startX + c*tileW;\r\n      let y = margin;\r\n      while(y < zoneH - margin - 1e-6){\r\n        let placed = false;\r\n        for(const L of lengths){\r\n          if(y + L <= zoneH - margin + 1e-6){\r\n            if(isValid(x,y,tileW,L)){\r\n              placements.push({ x,y, width:tileW, height:L, length:L });\r\n              counts[L]++;\r\n              y += L;\r\n              placed = true;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if(!placed){\r\n          y += tileW;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if(orientation==='both' || orientation==='horizontal') doHorizontal();\r\n  if(orientation==='both' || orientation==='vertical')   doVertical();\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}