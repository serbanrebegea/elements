{"ast":null,"code":"import * as turf from '@turf/turf';\n\n/**\r\n * Optimize placement touching at 207mm from the chosen corner.\r\n */\nexport default function optimizeLayout(polygonPoints, tileW, margin, lengthsIn, orientation, startCorner) {\n  // 1) Build & inward‐buffer polygon\n  const coords = polygonPoints.map(p => [p.x, p.y]);\n  coords.push(coords[0]);\n  const room = turf.polygon([coords]);\n  const inner = turf.buffer(room, -margin, {\n    units: 'meters'\n  });\n  if (!inner || !inner.geometry) return {\n    placements: [],\n    counts: {\n      4: 0,\n      2: 0,\n      1: 0\n    }\n  };\n\n  // 2) Compute bbox of inner\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\n\n  // 3) sort lengths big→small\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const minLen = lengths[lengths.length - 1];\n\n  // 4) determine scan direction from corner\n  const flags = {\n    'bottom-left': {\n      xDir: +1,\n      yStart: minY,\n      yEnd: maxY - tileW,\n      yStep: +tileW\n    },\n    'bottom-right': {\n      xDir: -1,\n      yStart: minY,\n      yEnd: maxY - tileW,\n      yStep: +tileW\n    },\n    'top-right': {\n      xDir: -1,\n      yStart: maxY - tileW,\n      yEnd: minY,\n      yStep: -tileW\n    },\n    'top-left': {\n      xDir: +1,\n      yStart: maxY - tileW,\n      yEnd: minY,\n      yStep: -tileW\n    }\n  }[startCorner];\n  const {\n    xDir,\n    yStart,\n    yEnd,\n    yStep\n  } = flags;\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // Helper: get horizontal segments at strip y…y+tileW\n  function getHSegs(y) {\n    const strip = turf.bboxPolygon([minX, y, maxX, y + tileW]);\n    const clip = turf.intersect(inner, strip);\n    if (!clip) return [];\n    const geoms = clip.geometry.type === 'Polygon' ? [clip.geometry.coordinates] : clip.geometry.coordinates;\n    return geoms.map(poly => {\n      const xs = poly[0].map(pt => pt[0]);\n      return [Math.min(...xs), Math.max(...xs)];\n    });\n  }\n\n  // Pack horizontal strips\n  function doHorizontal() {\n    for (let y = yStart; yStep > 0 ? y <= yEnd : y >= yEnd; y += yStep) {\n      const segs = getHSegs(y);\n      segs.forEach(([xMinSeg, xMaxSeg]) => {\n        let x = xDir > 0 ? xMinSeg : xMaxSeg;\n        while (xDir > 0 ? x <= xMaxSeg - minLen + 1e-6 : x >= xMinSeg + minLen - 1e-6) {\n          let placed = false;\n          for (const L of lengths) {\n            const px = xDir > 0 ? x : x - L;\n            if (px >= minX - 1e-6 && px + L <= maxX + 1e-6 && turf.booleanContains(inner, turf.polygon([[[px, y], [px + L, y], [px + L, y + tileW], [px, y + tileW], [px, y]]]))) {\n              placements.push({\n                x: px,\n                y,\n                width: L,\n                height: tileW,\n                length: L\n              });\n              counts[L]++;\n              x += L * xDir;\n              placed = true;\n              break;\n            }\n          }\n          if (!placed) x += minLen * xDir;\n        }\n      });\n    }\n  }\n\n  // Helper: vertical segments at strip x…x+tileW\n  function getVSegs(x) {\n    const strip = turf.bboxPolygon([x, minY, x + tileW, maxY]);\n    const clip = turf.intersect(inner, strip);\n    if (!clip) return [];\n    const geoms = clip.geometry.type === 'Polygon' ? [clip.geometry.coordinates] : clip.geometry.coordinates;\n    return geoms.map(poly => {\n      const ys = poly[0].map(pt => pt[1]);\n      return [Math.min(...ys), Math.max(...ys)];\n    });\n  }\n\n  // Pack vertical strips\n  function doVertical() {\n    // reuse yDir from flags\n    const yDir = yStep > 0 ? +1 : -1;\n    for (let x = xDir > 0 ? minX : maxX - tileW; xDir > 0 ? x <= maxX - tileW : x >= minX; x += tileW * xDir) {\n      const segs = getVSegs(x);\n      segs.forEach(([yMinSeg, yMaxSeg]) => {\n        let y = yDir > 0 ? yMinSeg : yMaxSeg;\n        while (yDir > 0 ? y <= yMaxSeg - minLen + 1e-6 : y >= yMinSeg + minLen - 1e-6) {\n          let placed = false;\n          for (const L of lengths) {\n            const py = yDir > 0 ? y : y - L;\n            if (py >= minY - 1e-6 && py + L <= maxY + 1e-6 && turf.booleanContains(inner, turf.polygon([[[x, py], [x + tileW, py], [x + tileW, py + L], [x, py + L], [x, py]]]))) {\n              placements.push({\n                x,\n                y: py,\n                width: tileW,\n                height: L,\n                length: L\n              });\n              counts[L]++;\n              y += L * yDir;\n              placed = true;\n              break;\n            }\n          }\n          if (!placed) y += tileW * yDir;\n        }\n      });\n    }\n  }\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\n  if (orientation === 'both' || orientation === 'vertical') doVertical();\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["turf","optimizeLayout","polygonPoints","tileW","margin","lengthsIn","orientation","startCorner","coords","map","p","x","y","push","room","polygon","inner","buffer","units","geometry","placements","counts","minX","minY","maxX","maxY","bbox","lengths","sort","a","b","minLen","length","flags","xDir","yStart","yEnd","yStep","getHSegs","strip","bboxPolygon","clip","intersect","geoms","type","coordinates","poly","xs","pt","Math","min","max","doHorizontal","segs","forEach","xMinSeg","xMaxSeg","placed","L","px","booleanContains","width","height","getVSegs","ys","doVertical","yDir","yMinSeg","yMaxSeg","py"],"sources":["c:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["import * as turf from '@turf/turf';\r\n\r\n/**\r\n * Optimize placement touching at 207mm from the chosen corner.\r\n */\r\nexport default function optimizeLayout(\r\n  polygonPoints,\r\n  tileW,\r\n  margin,\r\n  lengthsIn,\r\n  orientation,\r\n  startCorner\r\n) {\r\n  // 1) Build & inward‐buffer polygon\r\n  const coords = polygonPoints.map(p=>[p.x,p.y]);\r\n  coords.push(coords[0]);\r\n  const room = turf.polygon([coords]);\r\n  const inner = turf.buffer(room, -margin, {units:'meters'});\r\n  if (!inner || !inner.geometry) return {placements:[],counts:{4:0,2:0,1:0}};\r\n\r\n  // 2) Compute bbox of inner\r\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\r\n\r\n  // 3) sort lengths big→small\r\n  const lengths = [...lengthsIn].sort((a,b)=>b-a);\r\n  const minLen = lengths[lengths.length-1];\r\n\r\n  // 4) determine scan direction from corner\r\n  const flags = {\r\n    'bottom-left':  { xDir: +1, yStart: minY, yEnd: maxY-tileW,   yStep: +tileW },\r\n    'bottom-right': { xDir: -1, yStart: minY, yEnd: maxY-tileW,   yStep: +tileW },\r\n    'top-right':    { xDir: -1, yStart: maxY-tileW, yEnd: minY,   yStep: -tileW },\r\n    'top-left':     { xDir: +1, yStart: maxY-tileW, yEnd: minY,   yStep: -tileW },\r\n  }[startCorner];\r\n  const { xDir, yStart, yEnd, yStep } = flags;\r\n\r\n  const placements = [];\r\n  const counts = {4:0,2:0,1:0};\r\n\r\n  // Helper: get horizontal segments at strip y…y+tileW\r\n  function getHSegs(y) {\r\n    const strip = turf.bboxPolygon([minX, y, maxX, y+tileW]);\r\n    const clip  = turf.intersect(inner, strip);\r\n    if (!clip) return [];\r\n    const geoms = clip.geometry.type==='Polygon'\r\n      ? [clip.geometry.coordinates]\r\n      : clip.geometry.coordinates;\r\n    return geoms.map(poly=> {\r\n      const xs = poly[0].map(pt=>pt[0]);\r\n      return [Math.min(...xs), Math.max(...xs)];\r\n    });\r\n  }\r\n\r\n  // Pack horizontal strips\r\n  function doHorizontal() {\r\n    for (let y=yStart; (yStep>0?y<=yEnd:y>=yEnd); y+=yStep) {\r\n      const segs = getHSegs(y);\r\n      segs.forEach(([xMinSeg,xMaxSeg])=>{\r\n        let x = xDir>0? xMinSeg : xMaxSeg;\r\n        while (xDir>0\r\n          ? x <= xMaxSeg - minLen + 1e-6\r\n          : x >= xMinSeg + minLen - 1e-6\r\n        ) {\r\n          let placed=false;\r\n          for (const L of lengths) {\r\n            const px = xDir>0? x : x - L;\r\n            if (\r\n              px >= minX-1e-6 && px+L <= maxX+1e-6 &&\r\n              turf.booleanContains(inner,\r\n                turf.polygon([[\r\n                  [px,y],[px+L,y],\r\n                  [px+L,y+tileW],[px,y+tileW],\r\n                  [px,y]\r\n                ]])\r\n              )\r\n            ) {\r\n              placements.push({ x:px, y, width:L, height:tileW, length:L });\r\n              counts[L]++; \r\n              x += L * xDir;\r\n              placed=true;\r\n              break;\r\n            }\r\n          }\r\n          if(!placed) x += minLen * xDir;\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // Helper: vertical segments at strip x…x+tileW\r\n  function getVSegs(x) {\r\n    const strip = turf.bboxPolygon([x, minY, x+tileW, maxY]);\r\n    const clip  = turf.intersect(inner, strip);\r\n    if (!clip) return [];\r\n    const geoms = clip.geometry.type==='Polygon'\r\n      ? [clip.geometry.coordinates]\r\n      : clip.geometry.coordinates;\r\n    return geoms.map(poly=>{\r\n      const ys = poly[0].map(pt=>pt[1]);\r\n      return [Math.min(...ys), Math.max(...ys)];\r\n    });\r\n  }\r\n\r\n  // Pack vertical strips\r\n  function doVertical() {\r\n    // reuse yDir from flags\r\n    const yDir = (yStep>0? +1:-1);\r\n    for (\r\n      let x = xDir>0? minX : maxX-tileW;\r\n      xDir>0? x<=maxX-tileW : x>=minX;\r\n      x+=tileW*xDir\r\n    ) {\r\n      const segs = getVSegs(x);\r\n      segs.forEach(([yMinSeg,yMaxSeg])=>{\r\n        let y = yDir>0? yMinSeg : yMaxSeg;\r\n        while (yDir>0\r\n          ? y <= yMaxSeg - minLen + 1e-6\r\n          : y >= yMinSeg + minLen - 1e-6\r\n        ) {\r\n          let placed=false;\r\n          for (const L of lengths) {\r\n            const py = yDir>0? y : y - L;\r\n            if (\r\n              py>=minY-1e-6 && py+L<=maxY+1e-6 &&\r\n              turf.booleanContains(inner,\r\n                turf.polygon([[\r\n                  [x,py],[x+tileW,py],\r\n                  [x+tileW,py+L],[x,py+L],\r\n                  [x,py]\r\n                ]])\r\n              )\r\n            ) {\r\n              placements.push({ x, y:py, width:tileW, height:L, length:L });\r\n              counts[L]++;\r\n              y += L * yDir;\r\n              placed=true;\r\n              break;\r\n            }\r\n          }\r\n          if (!placed) y += tileW * yDir;\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  if (orientation==='both'||orientation==='horizontal')\r\n    doHorizontal();\r\n  if (orientation==='both'||orientation==='vertical')\r\n    doVertical();\r\n\r\n  return {placements, counts};\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}