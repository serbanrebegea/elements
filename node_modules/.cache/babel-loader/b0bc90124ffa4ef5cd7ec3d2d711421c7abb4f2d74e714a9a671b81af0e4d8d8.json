{"ast":null,"code":"// src/utils/optimizer.js\n\nimport * as turf from '@turf/turf';\n\n/**\r\n * @param {{x:number,y:number}[]} polygonPoints\r\n * @param {number} zoneW\r\n * @param {number} zoneH\r\n * @param {number[]} lengthsIn       // e.g. [4,2,1]\r\n * @param {number} tileW             // short side in m, e.g. 1.26\r\n * @param {number} margin            // 0.207\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n */\nexport default function optimizeLayout(polygonPoints, zoneW, zoneH, lengthsIn, tileW, margin, orientation) {\n  // 1) Build your room polygon and inward‑buffer by margin\n  const coords = polygonPoints.map(p => [p.x, p.y]);\n  coords.push(coords[0]);\n  const roomPoly = turf.polygon([coords]);\n  const inner = turf.buffer(roomPoly, -margin, {\n    units: 'meters'\n  });\n  if (!inner || !inner.geometry) {\n    return {\n      placements: [],\n      counts: {\n        4: 0,\n        2: 0,\n        1: 0\n      }\n    };\n  }\n\n  // sort lengths big→small\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // helper: does a rectangle at x,y of size w×h lie fully in \"inner\"?\n  function fitsInInner(x, y, w, h) {\n    const rect = turf.polygon([[[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]]]);\n    return turf.booleanContains(inner, rect);\n  }\n\n  // get the inner polygon's bbox\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\n\n  // 2) Horizontal strips packing\n  function doHorizontal() {\n    // for each strip at y .. y+tileW\n    for (let y = minY; y <= maxY - tileW + 1e-6; y += tileW) {\n      // build a bbox polygon of that strip\n      const strip = turf.bboxPolygon([minX, y, maxX, y + tileW]);\n      const clip = turf.intersect(inner, strip);\n      if (!clip) continue;\n\n      // normalize to array of coordinate‑rings\n      const polys = clip.geometry.type === 'Polygon' ? [clip.geometry.coordinates] : clip.geometry.coordinates;\n      for (const ring of polys) {\n        // the outer ring is ring[0]\n        const xs = ring[0].map(pt => pt[0]);\n        const xMinSeg = Math.min(...xs);\n        const xMaxSeg = Math.max(...xs);\n\n        // walk from xMinSeg → xMaxSeg\n        let x = xMinSeg;\n        while (x <= xMaxSeg - lengths[lengths.length - 1] + 1e-6) {\n          let placed = false;\n          for (const L of lengths) {\n            if (x + L <= xMaxSeg + 1e-6 && fitsInInner(x, y, L, tileW)) {\n              placements.push({\n                x,\n                y,\n                width: L,\n                height: tileW,\n                length: L\n              });\n              counts[L]++;\n              x += L; // advance by the long side\n              placed = true;\n              break;\n            }\n          }\n          if (!placed) {\n            // no tile fits here—skip by tileW\n            x += tileW;\n          }\n        }\n      }\n    }\n  }\n\n  // 3) Vertical strips packing\n  function doVertical() {\n    for (let x = minX; x <= maxX - tileW + 1e-6; x += tileW) {\n      const strip = turf.bboxPolygon([x, minY, x + tileW, maxY]);\n      const clip = turf.intersect(inner, strip);\n      if (!clip) continue;\n      const polys = clip.geometry.type === 'Polygon' ? [clip.geometry.coordinates] : clip.geometry.coordinates;\n      for (const ring of polys) {\n        const ys = ring[0].map(pt => pt[1]);\n        const yMinSeg = Math.min(...ys);\n        const yMaxSeg = Math.max(...ys);\n        let y = yMinSeg;\n        while (y <= yMaxSeg - lengths[lengths.length - 1] + 1e-6) {\n          let placed = false;\n          for (const L of lengths) {\n            if (y + L <= yMaxSeg + 1e-6 && fitsInInner(x, y, tileW, L)) {\n              placements.push({\n                x,\n                y,\n                width: tileW,\n                height: L,\n                length: L\n              });\n              counts[L]++;\n              y += L;\n              placed = true;\n              break;\n            }\n          }\n          if (!placed) {\n            y += tileW;\n          }\n        }\n      }\n    }\n  }\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\n  if (orientation === 'both' || orientation === 'vertical') doVertical();\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["turf","optimizeLayout","polygonPoints","zoneW","zoneH","lengthsIn","tileW","margin","orientation","coords","map","p","x","y","push","roomPoly","polygon","inner","buffer","units","geometry","placements","counts","lengths","sort","a","b","fitsInInner","w","h","rect","booleanContains","minX","minY","maxX","maxY","bbox","doHorizontal","strip","bboxPolygon","clip","intersect","polys","type","coordinates","ring","xs","pt","xMinSeg","Math","min","xMaxSeg","max","length","placed","L","width","height","doVertical","ys","yMinSeg","yMaxSeg"],"sources":["c:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["// src/utils/optimizer.js\r\n\r\nimport * as turf from '@turf/turf';\r\n\r\n/**\r\n * @param {{x:number,y:number}[]} polygonPoints\r\n * @param {number} zoneW\r\n * @param {number} zoneH\r\n * @param {number[]} lengthsIn       // e.g. [4,2,1]\r\n * @param {number} tileW             // short side in m, e.g. 1.26\r\n * @param {number} margin            // 0.207\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n */\r\nexport default function optimizeLayout(\r\n  polygonPoints,\r\n  zoneW,\r\n  zoneH,\r\n  lengthsIn,\r\n  tileW,\r\n  margin,\r\n  orientation\r\n) {\r\n  // 1) Build your room polygon and inward‑buffer by margin\r\n  const coords = polygonPoints.map(p => [p.x, p.y]);\r\n  coords.push(coords[0]);\r\n  const roomPoly = turf.polygon([coords]);\r\n  const inner    = turf.buffer(roomPoly, -margin, { units: 'meters' });\r\n  if (!inner || !inner.geometry) {\r\n    return { placements: [], counts: {4:0,2:0,1:0} };\r\n  }\r\n\r\n  // sort lengths big→small\r\n  const lengths = [...lengthsIn].sort((a,b) => b - a);\r\n  const placements = [];\r\n  const counts = {4:0,2:0,1:0};\r\n\r\n  // helper: does a rectangle at x,y of size w×h lie fully in \"inner\"?\r\n  function fitsInInner(x, y, w, h) {\r\n    const rect = turf.polygon([[\r\n      [x,     y],\r\n      [x + w, y],\r\n      [x + w, y + h],\r\n      [x,     y + h],\r\n      [x,     y]\r\n    ]]);\r\n    return turf.booleanContains(inner, rect);\r\n  }\r\n\r\n  // get the inner polygon's bbox\r\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\r\n\r\n  // 2) Horizontal strips packing\r\n  function doHorizontal() {\r\n    // for each strip at y .. y+tileW\r\n    for (let y = minY; y <= maxY - tileW + 1e-6; y += tileW) {\r\n      // build a bbox polygon of that strip\r\n      const strip = turf.bboxPolygon([minX, y, maxX, y + tileW]);\r\n      const clip  = turf.intersect(inner, strip);\r\n      if (!clip) continue;\r\n\r\n      // normalize to array of coordinate‑rings\r\n      const polys = clip.geometry.type === 'Polygon'\r\n        ? [clip.geometry.coordinates]\r\n        : clip.geometry.coordinates;\r\n\r\n      for (const ring of polys) {\r\n        // the outer ring is ring[0]\r\n        const xs = ring[0].map(pt => pt[0]);\r\n        const xMinSeg = Math.min(...xs);\r\n        const xMaxSeg = Math.max(...xs);\r\n\r\n        // walk from xMinSeg → xMaxSeg\r\n        let x = xMinSeg;\r\n        while (x <= xMaxSeg - lengths[lengths.length-1] + 1e-6) {\r\n          let placed = false;\r\n          for (const L of lengths) {\r\n            if (x + L <= xMaxSeg + 1e-6 && fitsInInner(x, y, L, tileW)) {\r\n              placements.push({ x, y, width: L, height: tileW, length: L });\r\n              counts[L]++;\r\n              x += L;    // advance by the long side\r\n              placed = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!placed) {\r\n            // no tile fits here—skip by tileW\r\n            x += tileW;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // 3) Vertical strips packing\r\n  function doVertical() {\r\n    for (let x = minX; x <= maxX - tileW + 1e-6; x += tileW) {\r\n      const strip = turf.bboxPolygon([x, minY, x + tileW, maxY]);\r\n      const clip  = turf.intersect(inner, strip);\r\n      if (!clip) continue;\r\n\r\n      const polys = clip.geometry.type === 'Polygon'\r\n        ? [clip.geometry.coordinates]\r\n        : clip.geometry.coordinates;\r\n\r\n      for (const ring of polys) {\r\n        const ys = ring[0].map(pt => pt[1]);\r\n        const yMinSeg = Math.min(...ys);\r\n        const yMaxSeg = Math.max(...ys);\r\n\r\n        let y = yMinSeg;\r\n        while (y <= yMaxSeg - lengths[lengths.length-1] + 1e-6) {\r\n          let placed = false;\r\n          for (const L of lengths) {\r\n            if (y + L <= yMaxSeg + 1e-6 && fitsInInner(x, y, tileW, L)) {\r\n              placements.push({ x, y, width: tileW, height: L, length: L });\r\n              counts[L]++;\r\n              y += L;\r\n              placed = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!placed) {\r\n            y += tileW;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\r\n  if (orientation === 'both' || orientation === 'vertical')   doVertical();\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}