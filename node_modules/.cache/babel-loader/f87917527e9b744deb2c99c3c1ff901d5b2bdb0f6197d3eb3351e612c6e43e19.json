{"ast":null,"code":"import * as turf from '@turf/turf';\n\n/**\r\n * @param {Array<{x:number,y:number}>} polygonPoints  – your room polygon, in meters\r\n * @param {number} zoneW   – bounding‑box width (m)\r\n * @param {number} zoneH   – bounding‑box height (m)\r\n * @param {number[]} lengthsIn – tile lengths to try, e.g. [4,2,1]\r\n * @param {number} tileW   – tile short side width (m), e.g. 1.26\r\n * @param {number} margin  – margin from walls (m), e.g. 0.207\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n *\r\n * @returns {{ placements: Array<{x,y,width,height,length}>, counts: {4:number,2:number,1:number} }}\r\n */\nexport default function optimizeLayout(polygonPoints, zoneW, zoneH, lengthsIn, tileW, margin, orientation) {\n  // 1) Build a Turf polygon of your room and buffer it *inward* by `margin`\n  const coords = polygonPoints.map(p => [p.x, p.y]);\n  coords.push(coords[0]); // close it\n  const roomPoly = turf.polygon([coords]);\n  // inward buffer: units meters\n  const allowed = turf.buffer(roomPoly, -margin, {\n    units: 'meters'\n  });\n  if (!allowed || !allowed.geometry) {\n    // too skinny to place anything\n    return {\n      placements: [],\n      counts: {\n        4: 0,\n        2: 0,\n        1: 0\n      }\n    };\n  }\n\n  // we’ll pack into these “strips”\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // always try big→small\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n\n  // Helper: for a given horizontal strip [y..y+tileW), compute its intersection with allowed\n  function getHorizontalSegments(y) {\n    const strip = turf.bboxPolygon([0, y, zoneW, y + tileW]);\n    const clip = turf.intersect(allowed, strip);\n    if (!clip) return [];\n    // clip can be Polygon or MultiPolygon\n    const geoms = clip.geometry.type === 'Polygon' ? [clip.geometry.coordinates] : clip.geometry.coordinates;\n    // Each \"ring\" is an array of [x,y] – we derive its x‑bounds\n    return geoms.map(ring => {\n      const xs = ring[0].map(pt => pt[0]);\n      return [Math.min(...xs), Math.max(...xs)];\n    });\n  }\n\n  // Helper: vertical strips [x..x+tileW)\n  function getVerticalSegments(x) {\n    const strip = turf.bboxPolygon([x, 0, x + tileW, zoneH]);\n    const clip = turf.intersect(allowed, strip);\n    if (!clip) return [];\n    const geoms = clip.geometry.type === 'Polygon' ? [clip.geometry.coordinates] : clip.geometry.coordinates;\n    return geoms.map(ring => {\n      const ys = ring[0].map(pt => pt[1]);\n      return [Math.min(...ys), Math.max(...ys)];\n    });\n  }\n\n  // 2) Pack horizontal‑long first\n  function doHorizontal() {\n    // generate rows from y = 0..zoneH in steps of tileW\n    const rows = Math.ceil(zoneH / tileW);\n    for (let r = 0; r < rows; r++) {\n      const y = r * tileW;\n      const segs = getHorizontalSegments(y);\n      segs.forEach(([xMin, xMax]) => {\n        let x = xMin;\n        // greedily walk this segment\n        while (x + tileW / 1000 < xMax) {\n          let placed = false;\n          for (const L of lengths) {\n            if (x + L <= xMax + 1e-6) {\n              // try place at (x,y) size L×tileW\n              placements.push({\n                x,\n                y,\n                width: L,\n                height: tileW,\n                length: L\n              });\n              counts[L]++;\n              x += L;\n              placed = true;\n              break;\n            }\n          }\n          if (!placed) {\n            // can’t fit any → skip forward a little\n            x += tileW;\n          }\n        }\n      });\n    }\n  }\n\n  // 3) Pack vertical‑long\n  function doVertical() {\n    const cols = Math.ceil(zoneW / tileW);\n    for (let c = 0; c < cols; c++) {\n      const x = c * tileW;\n      const segs = getVerticalSegments(x);\n      segs.forEach(([yMin, yMax]) => {\n        let y = yMin;\n        while (y + tileW / 1000 < yMax) {\n          let placed = false;\n          for (const L of lengths) {\n            if (y + L <= yMax + 1e-6) {\n              placements.push({\n                x,\n                y,\n                width: tileW,\n                height: L,\n                length: L\n              });\n              counts[L]++;\n              y += L;\n              placed = true;\n              break;\n            }\n          }\n          if (!placed) y += tileW;\n        }\n      });\n    }\n  }\n  if (orientation === 'both' || orientation === 'horizontal') {\n    doHorizontal();\n  }\n  if (orientation === 'both' || orientation === 'vertical') {\n    doVertical();\n  }\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["turf","optimizeLayout","polygonPoints","zoneW","zoneH","lengthsIn","tileW","margin","orientation","coords","map","p","x","y","push","roomPoly","polygon","allowed","buffer","units","geometry","placements","counts","lengths","sort","a","b","getHorizontalSegments","strip","bboxPolygon","clip","intersect","geoms","type","coordinates","ring","xs","pt","Math","min","max","getVerticalSegments","ys","doHorizontal","rows","ceil","r","segs","forEach","xMin","xMax","placed","L","width","height","length","doVertical","cols","c","yMin","yMax"],"sources":["c:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["\r\nimport * as turf from '@turf/turf';\r\n\r\n/**\r\n * @param {Array<{x:number,y:number}>} polygonPoints  – your room polygon, in meters\r\n * @param {number} zoneW   – bounding‑box width (m)\r\n * @param {number} zoneH   – bounding‑box height (m)\r\n * @param {number[]} lengthsIn – tile lengths to try, e.g. [4,2,1]\r\n * @param {number} tileW   – tile short side width (m), e.g. 1.26\r\n * @param {number} margin  – margin from walls (m), e.g. 0.207\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n *\r\n * @returns {{ placements: Array<{x,y,width,height,length}>, counts: {4:number,2:number,1:number} }}\r\n */\r\nexport default function optimizeLayout(\r\n  polygonPoints,\r\n  zoneW,\r\n  zoneH,\r\n  lengthsIn,\r\n  tileW,\r\n  margin,\r\n  orientation\r\n) {\r\n  // 1) Build a Turf polygon of your room and buffer it *inward* by `margin`\r\n  const coords = polygonPoints.map(p => [p.x, p.y]);\r\n  coords.push(coords[0]); // close it\r\n  const roomPoly = turf.polygon([coords]);\r\n  // inward buffer: units meters\r\n  const allowed = turf.buffer(roomPoly, -margin, { units: 'meters' });\r\n  if (!allowed || !allowed.geometry) {\r\n    // too skinny to place anything\r\n    return { placements: [], counts: {4:0,2:0,1:0} };\r\n  }\r\n\r\n  // we’ll pack into these “strips”\r\n  const placements = [];\r\n  const counts = { 4: 0, 2: 0, 1: 0 };\r\n\r\n  // always try big→small\r\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\r\n\r\n  // Helper: for a given horizontal strip [y..y+tileW), compute its intersection with allowed\r\n  function getHorizontalSegments(y) {\r\n    const strip = turf.bboxPolygon([0, y, zoneW, y + tileW]);\r\n    const clip = turf.intersect(allowed, strip);\r\n    if (!clip) return [];\r\n    // clip can be Polygon or MultiPolygon\r\n    const geoms = clip.geometry.type === 'Polygon'\r\n      ? [clip.geometry.coordinates]\r\n      : clip.geometry.coordinates;\r\n    // Each \"ring\" is an array of [x,y] – we derive its x‑bounds\r\n    return geoms.map(ring => {\r\n      const xs = ring[0].map(pt => pt[0]);\r\n      return [ Math.min(...xs), Math.max(...xs) ];\r\n    });\r\n  }\r\n\r\n  // Helper: vertical strips [x..x+tileW)\r\n  function getVerticalSegments(x) {\r\n    const strip = turf.bboxPolygon([x, 0, x + tileW, zoneH]);\r\n    const clip = turf.intersect(allowed, strip);\r\n    if (!clip) return [];\r\n    const geoms = clip.geometry.type === 'Polygon'\r\n      ? [clip.geometry.coordinates]\r\n      : clip.geometry.coordinates;\r\n    return geoms.map(ring => {\r\n      const ys = ring[0].map(pt => pt[1]);\r\n      return [ Math.min(...ys), Math.max(...ys) ];\r\n    });\r\n  }\r\n\r\n  // 2) Pack horizontal‑long first\r\n  function doHorizontal() {\r\n    // generate rows from y = 0..zoneH in steps of tileW\r\n    const rows = Math.ceil(zoneH / tileW);\r\n    for (let r = 0; r < rows; r++) {\r\n      const y = r * tileW;\r\n      const segs = getHorizontalSegments(y);\r\n      segs.forEach(([xMin, xMax]) => {\r\n        let x = xMin;\r\n        // greedily walk this segment\r\n        while (x + tileW/1000 < xMax) {\r\n          let placed = false;\r\n          for (const L of lengths) {\r\n            if (x + L <= xMax + 1e-6) {\r\n              // try place at (x,y) size L×tileW\r\n              placements.push({ x, y, width: L, height: tileW, length: L });\r\n              counts[L]++;\r\n              x += L;\r\n              placed = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!placed) {\r\n            // can’t fit any → skip forward a little\r\n            x += tileW;\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // 3) Pack vertical‑long\r\n  function doVertical() {\r\n    const cols = Math.ceil(zoneW / tileW);\r\n    for (let c = 0; c < cols; c++) {\r\n      const x = c * tileW;\r\n      const segs = getVerticalSegments(x);\r\n      segs.forEach(([yMin, yMax]) => {\r\n        let y = yMin;\r\n        while (y + tileW/1000 < yMax) {\r\n          let placed = false;\r\n          for (const L of lengths) {\r\n            if (y + L <= yMax + 1e-6) {\r\n              placements.push({ x, y, width: tileW, height: L, length: L });\r\n              counts[L]++;\r\n              y += L;\r\n              placed = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!placed) y += tileW;\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  if (orientation === 'both' || orientation === 'horizontal') {\r\n    doHorizontal();\r\n  }\r\n  if (orientation === 'both' || orientation === 'vertical') {\r\n    doVertical();\r\n  }\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}