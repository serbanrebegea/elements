{"ast":null,"code":"import * as turf from '@turf/turf';\n\n/**\r\n * Greedy pack inside polygon inset by margin.\r\n */\nexport default function optimizeLayout(polygonPoints, lengthsIn, tileW, margin, orientation) {\n  // 1) Build & inward‑buffer the room\n  const coords = polygonPoints.map(p => [p.x, p.y]);\n  coords.push(coords[0]);\n  const room = turf.polygon([coords]);\n  const inner = turf.buffer(room, -margin, {\n    units: 'meters'\n  });\n  if (!inner || !inner.geometry) {\n    return {\n      placements: []\n    };\n  }\n\n  // 2) BBox of inner area\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\n\n  // 3) Sort lengths descending\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const minLen = lengths[lengths.length - 1];\n  const placements = [];\n\n  // 4) Fit test\n  function fitsInside(x, y, w, h) {\n    const rect = turf.polygon([[[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]]]);\n    return turf.booleanContains(inner, rect);\n  }\n  const xStep = minLen;\n  const yStep = tileW;\n\n  // 5) Horizontal strips\n  if (orientation === 'both' || orientation === 'horizontal') {\n    for (let y = minY; y <= maxY - tileW; y += yStep) {\n      let x = minX;\n      while (x <= maxX - minLen) {\n        let placed = false;\n        for (const L of lengths) {\n          if (fitsInside(x, y, L, tileW)) {\n            placements.push({\n              x,\n              y,\n              width: L,\n              height: tileW,\n              length: L\n            });\n            x += L;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) x += xStep;\n      }\n    }\n  }\n\n  // 6) Vertical strips\n  if (orientation === 'both' || orientation === 'vertical') {\n    for (let x = minX; x <= maxX - tileW; x += xStep) {\n      let y = minY;\n      while (y <= maxY - minLen) {\n        let placed = false;\n        for (const L of lengths) {\n          if (fitsInside(x, y, tileW, L)) {\n            placements.push({\n              x,\n              y,\n              width: tileW,\n              height: L,\n              length: L\n            });\n            y += L;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) y += yStep;\n      }\n    }\n  }\n  return {\n    placements\n  };\n}","map":{"version":3,"names":["turf","optimizeLayout","polygonPoints","lengthsIn","tileW","margin","orientation","coords","map","p","x","y","push","room","polygon","inner","buffer","units","geometry","placements","minX","minY","maxX","maxY","bbox","lengths","sort","a","b","minLen","length","fitsInside","w","h","rect","booleanContains","xStep","yStep","placed","L","width","height"],"sources":["c:/apps/src/utils/optimizer.js"],"sourcesContent":["import * as turf from '@turf/turf';\r\n\r\n/**\r\n * Greedy pack inside polygon inset by margin.\r\n */\r\nexport default function optimizeLayout(\r\n  polygonPoints,\r\n  lengthsIn,\r\n  tileW,\r\n  margin,\r\n  orientation\r\n) {\r\n  // 1) Build & inward‑buffer the room\r\n  const coords = polygonPoints.map(p=>[p.x,p.y]);\r\n  coords.push(coords[0]);\r\n  const room  = turf.polygon([coords]);\r\n  const inner = turf.buffer(room, -margin, { units:'meters' });\r\n  if (!inner || !inner.geometry) {\r\n    return { placements: [] };\r\n  }\r\n\r\n  // 2) BBox of inner area\r\n  const [minX,minY,maxX,maxY] = turf.bbox(inner);\r\n\r\n  // 3) Sort lengths descending\r\n  const lengths = [...lengthsIn].sort((a,b)=>b-a);\r\n  const minLen  = lengths[lengths.length-1];\r\n\r\n  const placements = [];\r\n\r\n  // 4) Fit test\r\n  function fitsInside(x,y,w,h) {\r\n    const rect = turf.polygon([[\r\n      [x,y],[x+w,y],[x+w,y+h],[x,y+h],[x,y]\r\n    ]]);\r\n    return turf.booleanContains(inner, rect);\r\n  }\r\n\r\n  const xStep = minLen;\r\n  const yStep = tileW;\r\n\r\n  // 5) Horizontal strips\r\n  if (orientation==='both' || orientation==='horizontal') {\r\n    for (let y=minY; y<=maxY-tileW; y += yStep) {\r\n      let x=minX;\r\n      while (x<=maxX-minLen) {\r\n        let placed=false;\r\n        for (const L of lengths) {\r\n          if (fitsInside(x,y,L,tileW)) {\r\n            placements.push({ x, y,\r\n              width:L, height:tileW, length:L });\r\n            x += L;\r\n            placed = true; break;\r\n          }\r\n        }\r\n        if (!placed) x += xStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  // 6) Vertical strips\r\n  if (orientation==='both' || orientation==='vertical') {\r\n    for (let x=minX; x<=maxX-tileW; x += xStep) {\r\n      let y=minY;\r\n      while (y<=maxY-minLen) {\r\n        let placed=false;\r\n        for (const L of lengths) {\r\n          if (fitsInside(x,y,tileW,L)) {\r\n            placements.push({ x, y,\r\n              width:tileW, height:L, length:L });\r\n            y += L;\r\n            placed = true; break;\r\n          }\r\n        }\r\n        if (!placed) y += yStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { placements };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}