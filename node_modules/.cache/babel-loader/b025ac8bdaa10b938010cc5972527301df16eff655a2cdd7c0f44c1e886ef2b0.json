{"ast":null,"code":"import * as turf from '@turf/turf';\n\n/**\r\n * Packs tiles inside the polygon with a 207 mm border by\r\n * inward‑buffering the polygon, then greedy filling strips.\r\n */\nexport default function optimizeLayout(polygonPoints, lengthsIn, tileW, margin, orientation, startCorner) {\n  // 1) Build and inward‑buffer the polygon\n  const coords = polygonPoints.map(p => [p.x, p.y]);\n  coords.push(coords[0]);\n  const room = turf.polygon([coords]);\n  const inner = turf.buffer(room, -margin, {\n    units: 'meters'\n  });\n  if (!inner || !inner.geometry) return {\n    placements: [],\n    counts: {\n      4: 0,\n      2: 0,\n      1: 0\n    }\n  };\n\n  // 2) Bounding box of inner\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\n\n  // 3) Sort lengths desc\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const minL = lengths[lengths.length - 1];\n\n  // 4) Scan direction\n  const cornerMap = {\n    'bottom-left': {\n      dx: +1,\n      dy: +1\n    },\n    'bottom-right': {\n      dx: -1,\n      dy: +1\n    },\n    'top-right': {\n      dx: -1,\n      dy: -1\n    },\n    'top-left': {\n      dx: +1,\n      dy: -1\n    }\n  }[startCorner];\n  const {\n    dx,\n    dy\n  } = cornerMap;\n\n  // 5) Steps\n  const xStep = minL * dx;\n  const yStep = tileW * dy;\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // 6) Check if a tile fits inside the inner polygon\n  function fitsInside(x, y, w, h) {\n    const rect = turf.polygon([[[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]]]);\n    return turf.booleanContains(inner, rect);\n  }\n\n  // 7) Horizontal strips\n  function doHorizontal() {\n    for (let y = dy > 0 ? minY : maxY - tileW; dy > 0 ? y <= maxY - tileW : y >= minY; y += yStep) {\n      let x = dx > 0 ? minX : maxX - minL;\n      while (dx > 0 ? x <= maxX - minL : x >= minX) {\n        let placed = false;\n        for (const L of lengths) {\n          const px = dx > 0 ? x : x - L;\n          if (fitsInside(px, y, L, tileW)) {\n            placements.push({\n              x: px,\n              y,\n              width: L,\n              height: tileW,\n              length: L\n            });\n            counts[L]++;\n            x += L * dx;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) x += xStep;\n      }\n    }\n  }\n\n  // 8) Vertical strips\n  function doVertical() {\n    for (let x = dx > 0 ? minX : maxX - tileW; dx > 0 ? x <= maxX - tileW : x >= minX; x += xStep) {\n      let y = dy > 0 ? minY : maxY - minL;\n      while (dy > 0 ? y <= maxY - minL : y >= minY) {\n        let placed = false;\n        for (const L of lengths) {\n          const py = dy > 0 ? y : y - L;\n          if (fitsInside(x, py, tileW, L)) {\n            placements.push({\n              x,\n              y: py,\n              width: tileW,\n              height: L,\n              length: L\n            });\n            counts[L]++;\n            y += L * dy;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) y += yStep;\n      }\n    }\n  }\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\n  if (orientation === 'both' || orientation === 'vertical') doVertical();\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["turf","optimizeLayout","polygonPoints","lengthsIn","tileW","margin","orientation","startCorner","coords","map","p","x","y","push","room","polygon","inner","buffer","units","geometry","placements","counts","minX","minY","maxX","maxY","bbox","lengths","sort","a","b","minL","length","cornerMap","dx","dy","xStep","yStep","fitsInside","w","h","rect","booleanContains","doHorizontal","placed","L","px","width","height","doVertical","py"],"sources":["c:/apps/src/utils/optimizer.js"],"sourcesContent":["import * as turf from '@turf/turf';\r\n\r\n/**\r\n * Packs tiles inside the polygon with a 207 mm border by\r\n * inward‑buffering the polygon, then greedy filling strips.\r\n */\r\nexport default function optimizeLayout(\r\n  polygonPoints,\r\n  lengthsIn,\r\n  tileW,\r\n  margin,\r\n  orientation,\r\n  startCorner\r\n) {\r\n  // 1) Build and inward‑buffer the polygon\r\n  const coords = polygonPoints.map(p => [p.x, p.y]);\r\n  coords.push(coords[0]);\r\n  const room = turf.polygon([coords]);\r\n  const inner = turf.buffer(room, -margin, { units: 'meters' });\r\n  if (!inner || !inner.geometry) return { placements: [], counts: {4:0,2:0,1:0} };\r\n\r\n  // 2) Bounding box of inner\r\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\r\n\r\n  // 3) Sort lengths desc\r\n  const lengths = [...lengthsIn].sort((a,b)=>b-a);\r\n  const minL = lengths[lengths.length - 1];\r\n\r\n  // 4) Scan direction\r\n  const cornerMap = {\r\n    'bottom-left':  { dx:+1, dy:+1 },\r\n    'bottom-right': { dx:-1, dy:+1 },\r\n    'top-right':    { dx:-1, dy:-1 },\r\n    'top-left':     { dx:+1, dy:-1 }\r\n  }[startCorner];\r\n  const { dx, dy } = cornerMap;\r\n\r\n  // 5) Steps\r\n  const xStep = minL * dx;\r\n  const yStep = tileW * dy;\r\n\r\n  const placements = [];\r\n  const counts = {4:0,2:0,1:0};\r\n\r\n  // 6) Check if a tile fits inside the inner polygon\r\n  function fitsInside(x,y,w,h) {\r\n    const rect = turf.polygon([[\r\n      [x,y],[x+w,y],[x+w,y+h],[x,y+h],[x,y]\r\n    ]]);\r\n    return turf.booleanContains(inner, rect);\r\n  }\r\n\r\n  // 7) Horizontal strips\r\n  function doHorizontal() {\r\n    for (let y = dy>0 ? minY : maxY - tileW;\r\n         dy>0 ? y <= maxY - tileW : y >= minY;\r\n         y += yStep) {\r\n      let x = dx>0 ? minX : maxX - minL;\r\n      while (dx>0 ? x <= maxX - minL : x >= minX) {\r\n        let placed = false;\r\n        for (const L of lengths) {\r\n          const px = dx>0 ? x : x - L;\r\n          if (fitsInside(px, y, L, tileW)) {\r\n            placements.push({ x: px, y, width: L, height: tileW, length: L });\r\n            counts[L]++;\r\n            x += L * dx;\r\n            placed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!placed) x += xStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  // 8) Vertical strips\r\n  function doVertical() {\r\n    for (let x = dx>0 ? minX : maxX - tileW;\r\n         dx>0 ? x <= maxX - tileW : x >= minX;\r\n         x += xStep) {\r\n      let y = dy>0 ? minY : maxY - minL;\r\n      while (dy>0 ? y <= maxY - minL : y >= minY) {\r\n        let placed = false;\r\n        for (const L of lengths) {\r\n          const py = dy>0 ? y : y - L;\r\n          if (fitsInside(x, py, tileW, L)) {\r\n            placements.push({ x, y: py, width: tileW, height: L, length: L });\r\n            counts[L]++;\r\n            y += L * dy;\r\n            placed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!placed) y += yStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (orientation==='both' || orientation==='horizontal') doHorizontal();\r\n  if (orientation==='both' || orientation==='vertical')   doVertical();\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}