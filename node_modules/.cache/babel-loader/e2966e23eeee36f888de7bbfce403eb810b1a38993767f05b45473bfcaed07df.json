{"ast":null,"code":"// src/utils/optimizer.js\n\nimport * as turf from '@turf/turf';\n\n/**\r\n * Packs tiles so they all lie within the polygon, with a 207 mm border\r\n * around the entire tile shape.\r\n *\r\n * @param {{x:number,y:number}[]} polygonPoints\r\n * @param {number[]} lengthsIn     // e.g. [4,2,1]\r\n * @param {number} tileW           // tile short side (m), e.g. 1.26\r\n * @param {number} margin          // clearance from polygon (m), e.g. 0.207\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n * @param {'bottom-left'|'bottom-right'|'top-right'|'top-left'} startCorner\r\n *\r\n * @returns {{ placements: Array<{x,y,width,height,length}>, counts:{4:number,2:number,1:number} }}\r\n */\nexport default function optimizeLayout(polygonPoints, lengthsIn, tileW, margin, orientation, startCorner) {\n  // 1) Build your room polygon and inward‑buffer by `margin` meters\n  const coords = polygonPoints.map(p => [p.x, p.y]);\n  coords.push(coords[0]); // close ring\n  const roomPoly = turf.polygon([coords]);\n  const innerPoly = turf.buffer(roomPoly, -margin, {\n    units: 'meters'\n  });\n  if (!innerPoly || !innerPoly.geometry) {\n    // Not enough room once shrunk\n    return {\n      placements: [],\n      counts: {\n        4: 0,\n        2: 0,\n        1: 0\n      }\n    };\n  }\n\n  // 2) Get bounding box of the allowed (shrunk) region\n  const [minX, minY, maxX, maxY] = turf.bbox(innerPoly);\n\n  // 3) Sort tile lengths big→small\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const minLen = lengths[lengths.length - 1];\n\n  // 4) Determine scan directions from startCorner\n  const cornerMap = {\n    'bottom-left': {\n      dx: +1,\n      dy: +1\n    },\n    'bottom-right': {\n      dx: -1,\n      dy: +1\n    },\n    'top-right': {\n      dx: -1,\n      dy: -1\n    },\n    'top-left': {\n      dx: +1,\n      dy: -1\n    }\n  }[startCorner];\n  const {\n    dx,\n    dy\n  } = cornerMap;\n\n  // 5) Scan bounds and steps\n  const xStart = dx > 0 ? minX : maxX - tileW;\n  const xEnd = dx > 0 ? maxX - tileW : minX;\n  const yStart = dy > 0 ? minY : maxY - tileW;\n  const yEnd = dy > 0 ? maxY - tileW : minY;\n  const xStep = tileW * dx;\n  const yStep = tileW * dy;\n\n  // 6) Helper: does rectangle sit fully inside innerPoly?\n  function fitsInside(x, y, w, h) {\n    const rect = turf.polygon([[[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]]]);\n    return turf.booleanContains(innerPoly, rect);\n  }\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // 7) Horizontal packing\n  function doHorizontal() {\n    for (let y = yStart; dy > 0 ? y <= yEnd : y >= yEnd; y += yStep) {\n      let x = xStart;\n      while (dx > 0 ? x <= maxX - margin - minLen : x >= minX + margin) {\n        let placed = false;\n        for (const L of lengths) {\n          if (fitsInside(x, y, L, tileW)) {\n            placements.push({\n              x,\n              y,\n              width: L,\n              height: tileW,\n              length: L\n            });\n            counts[L]++;\n            x += L * dx;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) x += xStep;\n      }\n    }\n  }\n\n  // 8) Vertical packing\n  function doVertical() {\n    for (let x = xStart; dx > 0 ? x <= xEnd : x >= xEnd; x += xStep) {\n      let y = yStart;\n      while (dy > 0 ? y <= maxY - margin - minLen : y >= minY + margin) {\n        let placed = false;\n        for (const L of lengths) {\n          if (fitsInside(x, y, tileW, L)) {\n            placements.push({\n              x,\n              y,\n              width: tileW,\n              height: L,\n              length: L\n            });\n            counts[L]++;\n            y += L * dy;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) y += yStep;\n      }\n    }\n  }\n  if (orientation === 'both' || orientation === 'horizontal') {\n    doHorizontal();\n  }\n  if (orientation === 'both' || orientation === 'vertical') {\n    doVertical();\n  }\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["turf","optimizeLayout","polygonPoints","lengthsIn","tileW","margin","orientation","startCorner","coords","map","p","x","y","push","roomPoly","polygon","innerPoly","buffer","units","geometry","placements","counts","minX","minY","maxX","maxY","bbox","lengths","sort","a","b","minLen","length","cornerMap","dx","dy","xStart","xEnd","yStart","yEnd","xStep","yStep","fitsInside","w","h","rect","booleanContains","doHorizontal","placed","L","width","height","doVertical"],"sources":["c:/apps/src/utils/optimizer.js"],"sourcesContent":["// src/utils/optimizer.js\r\n\r\nimport * as turf from '@turf/turf';\r\n\r\n/**\r\n * Packs tiles so they all lie within the polygon, with a 207 mm border\r\n * around the entire tile shape.\r\n *\r\n * @param {{x:number,y:number}[]} polygonPoints\r\n * @param {number[]} lengthsIn     // e.g. [4,2,1]\r\n * @param {number} tileW           // tile short side (m), e.g. 1.26\r\n * @param {number} margin          // clearance from polygon (m), e.g. 0.207\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n * @param {'bottom-left'|'bottom-right'|'top-right'|'top-left'} startCorner\r\n *\r\n * @returns {{ placements: Array<{x,y,width,height,length}>, counts:{4:number,2:number,1:number} }}\r\n */\r\nexport default function optimizeLayout(\r\n  polygonPoints,\r\n  lengthsIn,\r\n  tileW,\r\n  margin,\r\n  orientation,\r\n  startCorner\r\n) {\r\n  // 1) Build your room polygon and inward‑buffer by `margin` meters\r\n  const coords = polygonPoints.map(p => [p.x, p.y]);\r\n  coords.push(coords[0]); // close ring\r\n  const roomPoly = turf.polygon([coords]);\r\n  const innerPoly = turf.buffer(roomPoly, -margin, { units: 'meters' });\r\n  if (!innerPoly || !innerPoly.geometry) {\r\n    // Not enough room once shrunk\r\n    return { placements: [], counts: {4:0,2:0,1:0} };\r\n  }\r\n\r\n  // 2) Get bounding box of the allowed (shrunk) region\r\n  const [minX, minY, maxX, maxY] = turf.bbox(innerPoly);\r\n\r\n  // 3) Sort tile lengths big→small\r\n  const lengths = [...lengthsIn].sort((a,b) => b - a);\r\n  const minLen = lengths[lengths.length - 1];\r\n\r\n  // 4) Determine scan directions from startCorner\r\n  const cornerMap = {\r\n    'bottom-left':  { dx:+1, dy:+1 },\r\n    'bottom-right': { dx:-1, dy:+1 },\r\n    'top-right':    { dx:-1, dy:-1 },\r\n    'top-left':     { dx:+1, dy:-1 }\r\n  }[startCorner];\r\n  const { dx, dy } = cornerMap;\r\n\r\n  // 5) Scan bounds and steps\r\n  const xStart = dx > 0 ? minX : maxX - tileW;\r\n  const xEnd   = dx > 0 ? maxX - tileW : minX;\r\n  const yStart = dy > 0 ? minY : maxY - tileW;\r\n  const yEnd   = dy > 0 ? maxY - tileW : minY;\r\n\r\n  const xStep = tileW * dx;\r\n  const yStep = tileW * dy;\r\n\r\n  // 6) Helper: does rectangle sit fully inside innerPoly?\r\n  function fitsInside(x, y, w, h) {\r\n    const rect = turf.polygon([[\r\n      [x,     y],\r\n      [x + w, y],\r\n      [x + w, y + h],\r\n      [x,     y + h],\r\n      [x,     y]\r\n    ]]);\r\n    return turf.booleanContains(innerPoly, rect);\r\n  }\r\n\r\n  const placements = [];\r\n  const counts = {4:0,2:0,1:0};\r\n\r\n  // 7) Horizontal packing\r\n  function doHorizontal() {\r\n    for (let y = yStart; dy>0 ? y <= yEnd : y >= yEnd; y += yStep) {\r\n      let x = xStart;\r\n      while (dx>0 ? x <= maxX - margin - minLen : x >= minX + margin) {\r\n        let placed = false;\r\n        for (const L of lengths) {\r\n          if (fitsInside(x, y, L, tileW)) {\r\n            placements.push({ x, y, width: L, height: tileW, length: L });\r\n            counts[L]++;\r\n            x += L * dx;\r\n            placed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!placed) x += xStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  // 8) Vertical packing\r\n  function doVertical() {\r\n    for (let x = xStart; dx>0 ? x <= xEnd : x >= xEnd; x += xStep) {\r\n      let y = yStart;\r\n      while (dy>0 ? y <= maxY - margin - minLen : y >= minY + margin) {\r\n        let placed = false;\r\n        for (const L of lengths) {\r\n          if (fitsInside(x, y, tileW, L)) {\r\n            placements.push({ x, y, width: tileW, height: L, length: L });\r\n            counts[L]++;\r\n            y += L * dy;\r\n            placed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!placed) y += yStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (orientation === 'both' || orientation === 'horizontal') {\r\n    doHorizontal();\r\n  }\r\n  if (orientation === 'both' || orientation === 'vertical') {\r\n    doVertical();\r\n  }\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}