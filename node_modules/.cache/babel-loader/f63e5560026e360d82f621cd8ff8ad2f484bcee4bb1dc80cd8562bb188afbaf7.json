{"ast":null,"code":"import * as turf from '@turf/turf';\n\n/**\r\n * Greedy pack inside polygon minus margin buffer.\r\n */\nexport default function optimizeLayout(polygonPoints, lengthsIn, tileW, margin, orientation, startCorner) {\n  // Build and inward‑buffer the polygon\n  const coords = polygonPoints.map(p => [p.x, p.y]);\n  coords.push(coords[0]);\n  const room = turf.polygon([coords]);\n  const inner = turf.buffer(room, -margin, {\n    units: 'meters'\n  });\n  if (!inner || !inner.geometry) {\n    return {\n      placements: [],\n      counts: {\n        4: 0,\n        2: 0,\n        1: 0\n      }\n    };\n  }\n\n  // BBox of inner\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\n\n  // Sort lengths desc\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const minLen = lengths[lengths.length - 1];\n\n  // Start corner direction\n  const {\n    dx,\n    dy\n  } = {\n    'bottom-left': {\n      dx: +1,\n      dy: +1\n    },\n    'bottom-right': {\n      dx: -1,\n      dy: +1\n    },\n    'top-right': {\n      dx: -1,\n      dy: -1\n    },\n    'top-left': {\n      dx: +1,\n      dy: -1\n    }\n  }[startCorner];\n  const placements = [];\n\n  // Fit test\n  function fitsInside(x, y, w, h) {\n    const rect = turf.polygon([[[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]]]);\n    return turf.booleanContains(inner, rect);\n  }\n  const xStep = minLen * dx;\n  const yStep = tileW * dy;\n\n  // Horizontal strips\n  function doHorizontal() {\n    for (let y = dy > 0 ? minY : maxY - tileW; dy > 0 ? y <= maxY - tileW : y >= minY; y += yStep) {\n      let x = dx > 0 ? minX : maxX - minLen;\n      while (dx > 0 ? x <= maxX - minLen : x >= minX) {\n        let placed = false;\n        for (const L of lengths) {\n          const px = dx > 0 ? x : x - L;\n          if (fitsInside(px, y, L, tileW)) {\n            placements.push({\n              x: px,\n              y,\n              width: L,\n              height: tileW,\n              length: L\n            });\n            x += L * dx;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) x += xStep;\n      }\n    }\n  }\n\n  // Vertical strips\n  function doVertical() {\n    for (let x = dx > 0 ? minX : maxX - tileW; dx > 0 ? x <= maxX - tileW : x >= minX; x += xStep) {\n      let y = dy > 0 ? minY : maxY - minLen;\n      while (dy > 0 ? y <= maxY - minLen : y >= minY) {\n        let placed = false;\n        for (const L of lengths) {\n          const py = dy > 0 ? y : y - L;\n          if (fitsInside(x, py, tileW, L)) {\n            placements.push({\n              x,\n              y: py,\n              width: tileW,\n              height: L,\n              length: L\n            });\n            y += L * dy;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) y += yStep;\n      }\n    }\n  }\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\n  if (orientation === 'both' || orientation === 'vertical') doVertical();\n\n  // We only return placements here; counts are computed in App.js\n  return {\n    placements\n  };\n}","map":{"version":3,"names":["turf","optimizeLayout","polygonPoints","lengthsIn","tileW","margin","orientation","startCorner","coords","map","p","x","y","push","room","polygon","inner","buffer","units","geometry","placements","counts","minX","minY","maxX","maxY","bbox","lengths","sort","a","b","minLen","length","dx","dy","fitsInside","w","h","rect","booleanContains","xStep","yStep","doHorizontal","placed","L","px","width","height","doVertical","py"],"sources":["c:/apps/src/utils/optimizer.js"],"sourcesContent":["import * as turf from '@turf/turf';\r\n\r\n/**\r\n * Greedy pack inside polygon minus margin buffer.\r\n */\r\nexport default function optimizeLayout(\r\n  polygonPoints,\r\n  lengthsIn,\r\n  tileW,\r\n  margin,\r\n  orientation,\r\n  startCorner\r\n) {\r\n  // Build and inward‑buffer the polygon\r\n  const coords = polygonPoints.map(p=>[p.x,p.y]);\r\n  coords.push(coords[0]);\r\n  const room  = turf.polygon([coords]);\r\n  const inner = turf.buffer(room, -margin, { units:'meters' });\r\n  if (!inner || !inner.geometry) {\r\n    return { placements: [], counts: {4:0,2:0,1:0} };\r\n  }\r\n\r\n  // BBox of inner\r\n  const [minX,minY,maxX,maxY] = turf.bbox(inner);\r\n\r\n  // Sort lengths desc\r\n  const lengths = [...lengthsIn].sort((a,b)=>b-a);\r\n  const minLen  = lengths[lengths.length-1];\r\n\r\n  // Start corner direction\r\n  const { dx, dy } = {\r\n    'bottom-left':  {dx:+1,dy:+1},\r\n    'bottom-right': {dx:-1,dy:+1},\r\n    'top-right':    {dx:-1,dy:-1},\r\n    'top-left':     {dx:+1,dy:-1}\r\n  }[startCorner];\r\n\r\n  const placements = [];\r\n\r\n  // Fit test\r\n  function fitsInside(x,y,w,h) {\r\n    const rect = turf.polygon([[\r\n      [x,y],[x+w,y],[x+w,y+h],[x,y+h],[x,y]\r\n    ]]);\r\n    return turf.booleanContains(inner, rect);\r\n  }\r\n\r\n  const xStep = minLen * dx;\r\n  const yStep = tileW  * dy;\r\n\r\n  // Horizontal strips\r\n  function doHorizontal() {\r\n    for (let y = dy>0?minY:maxY-tileW;\r\n         dy>0? y<=maxY-tileW : y>=minY;\r\n         y += yStep) {\r\n      let x = dx>0?minX:maxX-minLen;\r\n      while (dx>0? x<=maxX-minLen : x>=minX) {\r\n        let placed=false;\r\n        for (const L of lengths) {\r\n          const px = dx>0? x : x-L;\r\n          if (fitsInside(px,y,L,tileW)) {\r\n            placements.push({x:px,y,width:L,height:tileW,length:L});\r\n            x += L*dx; placed=true; break;\r\n          }\r\n        }\r\n        if (!placed) x += xStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Vertical strips\r\n  function doVertical() {\r\n    for (let x = dx>0?minX:maxX-tileW;\r\n         dx>0? x<=maxX-tileW : x>=minX;\r\n         x += xStep) {\r\n      let y = dy>0?minY:maxY-minLen;\r\n      while (dy>0? y<=maxY-minLen : y>=minY) {\r\n        let placed=false;\r\n        for (const L of lengths) {\r\n          const py = dy>0? y : y-L;\r\n          if (fitsInside(x,py,tileW,L)) {\r\n            placements.push({x,y:py,width:tileW,height:L,length:L});\r\n            y += L*dy; placed=true; break;\r\n          }\r\n        }\r\n        if (!placed) y += yStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (orientation==='both' || orientation==='horizontal') doHorizontal();\r\n  if (orientation==='both' || orientation==='vertical')   doVertical();\r\n\r\n  // We only return placements here; counts are computed in App.js\r\n  return { placements };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}