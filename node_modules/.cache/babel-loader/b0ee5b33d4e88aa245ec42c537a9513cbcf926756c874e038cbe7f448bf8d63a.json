{"ast":null,"code":"/**\r\n * Packs tiles edge‑to‑edge hugging polygon + 207 mm margin.\r\n * \r\n * @param points    Array<{x,y}> polygon vertices\r\n * @param lengthsIn [4,2,1] long‑side options\r\n * @param tileW     short side (1.26)\r\n * @param margin    clearance (0.207)\r\n * @param orient    'both'|'horizontal'|'vertical'\r\n * @param corner    start corner\r\n */\nexport default function optimizeLayout(points, lengthsIn, tileW, margin, orient, corner) {\n  // point‑in‑poly\n  function pip(x, y, vs) {\n    let inside = false;\n    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n      const xi = vs[i].x,\n        yi = vs[i].y;\n      const xj = vs[j].x,\n        yj = vs[j].y;\n      const inter = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n      if (inter) inside = !inside;\n    }\n    return inside;\n  }\n  // dist point→segment\n  function psd(px, py, x1, y1, x2, y2) {\n    const A = px - x1,\n      B = py - y1,\n      C = x2 - x1,\n      D = y2 - y1;\n    const dot = A * C + B * D,\n      len2 = C * C + D * D;\n    let t = len2 ? dot / len2 : -1,\n      xx,\n      yy;\n    if (t < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (t > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + t * C;\n      yy = y1 + t * D;\n    }\n    const dx = px - xx,\n      dy = py - yy;\n    return Math.hypot(dx, dy);\n  }\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // validity: inside poly, ≥margin, no overlap\n  function valid(x, y, w, h) {\n    const c = [{\n      x,\n      y\n    }, {\n      x: x + w,\n      y\n    }, {\n      x,\n      y: y + h\n    }, {\n      x: x + w,\n      y: y + h\n    }];\n    for (const p of c) {\n      if (!pip(p.x, p.y, points)) return false;\n    }\n    for (const p of c) {\n      for (let i = 0, j = points.length - 1; i < points.length; j = i++) {\n        const a = points[i],\n          b = points[j];\n        if (psd(p.x, p.y, a.x, a.y, b.x, b.y) < margin) return false;\n      }\n    }\n    for (const t of placements) {\n      if (!(x + w <= t.x || t.x + t.width <= x || y + h <= t.y || t.y + t.height <= y)) return false;\n    }\n    return true;\n  }\n\n  // bounds\n  const xs = points.map(p => p.x),\n    ys = points.map(p => p.y);\n  const minX = Math.min(...xs),\n    maxX = Math.max(...xs);\n  const minY = Math.min(...ys),\n    maxY = Math.max(...ys);\n\n  // directions from corner\n  const map = {\n    'bottom-left': {\n      dx: +1,\n      dy: +1\n    },\n    'bottom-right': {\n      dx: -1,\n      dy: +1\n    },\n    'top-right': {\n      dx: -1,\n      dy: -1\n    },\n    'top-left': {\n      dx: +1,\n      dy: -1\n    }\n  }[corner];\n  const {\n    dx,\n    dy\n  } = map;\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const minL = lengths[lengths.length - 1];\n  const xStart = dx > 0 ? minX + margin : maxX - margin;\n  const xEnd = dx > 0 ? maxX - margin - minL : minX + margin + minL;\n  const yStart = dy > 0 ? minY + margin : maxY - margin - tileW;\n  const yEnd = dy > 0 ? maxY - margin - tileW : minY + margin;\n  const xStep = minL * dx;\n  const yStep = tileW * dy;\n\n  // horizontal packing\n  function hor() {\n    for (let y = yStart; dy > 0 ? y <= yEnd : y >= yEnd; y += yStep) {\n      let x = xStart;\n      while (dx > 0 ? x <= xEnd : x >= xEnd) {\n        let placed = false;\n        for (const L of lengths) {\n          const px = dx > 0 ? x : x - L;\n          if (valid(px, y, L, tileW)) {\n            placements.push({\n              x: px,\n              y,\n              width: L,\n              height: tileW,\n              length: L\n            });\n            counts[L]++;\n            x += L * dx;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) x += xStep;\n      }\n    }\n  }\n  // vertical packing\n  function vert() {\n    for (let x = xStart; dx > 0 ? x <= xEnd : x >= xEnd; x += yStep) {\n      let y = yStart;\n      while (dy > 0 ? y <= yEnd : y >= yEnd) {\n        let placed = false;\n        for (const L of lengths) {\n          const py = dy > 0 ? y : y - L;\n          if (valid(x, py, tileW, L)) {\n            placements.push({\n              x,\n              y: py,\n              width: tileW,\n              height: L,\n              length: L\n            });\n            counts[L]++;\n            y += L * dy;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) y += yStep;\n      }\n    }\n  }\n  if (orient === 'both' || orient === 'horizontal') hor();\n  if (orient === 'both' || orient === 'vertical') vert();\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["optimizeLayout","points","lengthsIn","tileW","margin","orient","corner","pip","x","y","vs","inside","i","j","length","xi","yi","xj","yj","inter","psd","px","py","x1","y1","x2","y2","A","B","C","D","dot","len2","t","xx","yy","dx","dy","Math","hypot","placements","counts","valid","w","h","c","p","a","b","width","height","xs","map","ys","minX","min","maxX","max","minY","maxY","lengths","sort","minL","xStart","xEnd","yStart","yEnd","xStep","yStep","hor","placed","L","push","vert"],"sources":["c:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["/**\r\n * Packs tiles edge‑to‑edge hugging polygon + 207 mm margin.\r\n * \r\n * @param points    Array<{x,y}> polygon vertices\r\n * @param lengthsIn [4,2,1] long‑side options\r\n * @param tileW     short side (1.26)\r\n * @param margin    clearance (0.207)\r\n * @param orient    'both'|'horizontal'|'vertical'\r\n * @param corner    start corner\r\n */\r\nexport default function optimizeLayout(\r\n  points, lengthsIn, tileW, margin,\r\n  orient, corner\r\n) {\r\n  // point‑in‑poly\r\n  function pip(x,y,vs){\r\n    let inside=false;\r\n    for(let i=0,j=vs.length-1;i<vs.length;j=i++){\r\n      const xi=vs[i].x, yi=vs[i].y;\r\n      const xj=vs[j].x, yj=vs[j].y;\r\n      const inter = (yi>y)!==(yj>y)\r\n        && x < (xj-xi)*(y-yi)/(yj-yi)+xi;\r\n      if(inter) inside=!inside;\r\n    }\r\n    return inside;\r\n  }\r\n  // dist point→segment\r\n  function psd(px,py,x1,y1,x2,y2){\r\n    const A=px-x1, B=py-y1, C=x2-x1, D=y2-y1;\r\n    const dot=A*C+B*D, len2=C*C+D*D;\r\n    let t = len2? dot/len2 : -1, xx, yy;\r\n    if(t<0){ xx=x1; yy=y1; }\r\n    else if(t>1){ xx=x2; yy=y2; }\r\n    else { xx=x1+t*C; yy=y1+t*D; }\r\n    const dx=px-xx, dy=py-yy;\r\n    return Math.hypot(dx,dy);\r\n  }\r\n\r\n  const placements = [];\r\n  const counts = {4:0,2:0,1:0};\r\n\r\n  // validity: inside poly, ≥margin, no overlap\r\n  function valid(x,y,w,h){\r\n    const c=[\r\n      {x,y},{x:x+w,y},\r\n      {x,y:y+h},{x:x+w,y:y+h}\r\n    ];\r\n    for(const p of c){\r\n      if(!pip(p.x,p.y,points)) return false;\r\n    }\r\n    for(const p of c){\r\n      for(let i=0,j=points.length-1;i<points.length;j=i++){\r\n        const a=points[i], b=points[j];\r\n        if(psd(p.x,p.y,a.x,a.y,b.x,b.y)<margin) return false;\r\n      }\r\n    }\r\n    for(const t of placements){\r\n      if(!(\r\n        x+w<=t.x ||\r\n        t.x+t.width<=x ||\r\n        y+h<=t.y ||\r\n        t.y+t.height<=y\r\n      )) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // bounds\r\n  const xs=points.map(p=>p.x), ys=points.map(p=>p.y);\r\n  const minX=Math.min(...xs), maxX=Math.max(...xs);\r\n  const minY=Math.min(...ys), maxY=Math.max(...ys);\r\n\r\n  // directions from corner\r\n  const map = {\r\n    'bottom-left':  { dx:+1, dy:+1 },\r\n    'bottom-right': { dx:-1, dy:+1 },\r\n    'top-right':    { dx:-1, dy:-1 },\r\n    'top-left':     { dx:+1, dy:-1 }\r\n  }[corner];\r\n  const {dx,dy}=map;\r\n\r\n  const lengths = [...lengthsIn].sort((a,b)=>b-a);\r\n  const minL = lengths[lengths.length-1];\r\n\r\n  const xStart = dx>0? minX+margin : maxX-margin;\r\n  const xEnd   = dx>0? maxX-margin-minL : minX+margin+minL;\r\n  const yStart = dy>0? minY+margin : maxY-margin-tileW;\r\n  const yEnd   = dy>0? maxY-margin-tileW : minY+margin;\r\n  const xStep  = minL * dx;\r\n  const yStep  = tileW * dy;\r\n\r\n  // horizontal packing\r\n  function hor() {\r\n    for(let y=yStart; (dy>0?y<=yEnd:y>=yEnd); y+=yStep){\r\n      let x=xStart;\r\n      while(dx>0?x<=xEnd:x>=xEnd){\r\n        let placed=false;\r\n        for(const L of lengths){\r\n          const px=dx>0?x:x-L;\r\n          if(valid(px,y,L,tileW)){\r\n            placements.push({x:px,y,width:L,height:tileW,length:L});\r\n            counts[L]++; x+=L*dx; placed=true; break;\r\n          }\r\n        }\r\n        if(!placed) x+=xStep;\r\n      }\r\n    }\r\n  }\r\n  // vertical packing\r\n  function vert() {\r\n    for(let x=xStart; (dx>0?x<=xEnd:x>=xEnd); x+=yStep){\r\n      let y=yStart;\r\n      while(dy>0?y<=yEnd:y>=yEnd){\r\n        let placed=false;\r\n        for(const L of lengths){\r\n          const py=dy>0?y:y-L;\r\n          if(valid(x,py,tileW,L)){\r\n            placements.push({x,y:py,width:tileW,height:L,length:L});\r\n            counts[L]++; y+=L*dy; placed=true; break;\r\n          }\r\n        }\r\n        if(!placed) y+=yStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  if(orient==='both'||orient==='horizontal') hor();\r\n  if(orient==='both'||orient==='vertical') vert();\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}