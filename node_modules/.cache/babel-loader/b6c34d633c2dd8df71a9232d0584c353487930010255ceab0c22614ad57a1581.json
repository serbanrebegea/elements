{"ast":null,"code":"// src/utils/optimizer.js\n\n// Greedy edge‑to‑edge packer that hugs your polygon + 207 mm clearance\nexport default function optimizeLayout(polygonPoints,\n// [{x,y},…] in meters\nzoneW,\n// bounding‐box W (m) – only for canvas size\nzoneH,\n// bounding‐box H (m)\nlengthsIn,\n// e.g. [4,2,1]\ntileW,\n// tile short side (m), e.g. 1.26\nmargin,\n// clearance from walls (m), e.g. 0.207\norientation // 'both' | 'horizontal' | 'vertical'\n) {\n  // --- 1) Helpers ---\n\n  // point‐in‐polygon (ray‐cast)\n  function pointInPoly(x, y, vs) {\n    let inside = false;\n    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n      const xi = vs[i].x,\n        yi = vs[i].y;\n      const xj = vs[j].x,\n        yj = vs[j].y;\n      const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n      if (intersect) inside = !inside;\n    }\n    return inside;\n  }\n\n  // distance from (px,py) to segment [(x1,y1)-(x2,y2)]\n  function ptSegDist(px, py, x1, y1, x2, y2) {\n    const A = px - x1,\n      B = py - y1,\n      C = x2 - x1,\n      D = y2 - y1;\n    const dot = A * C + B * D,\n      len2 = C * C + D * D;\n    let t = len2 ? dot / len2 : -1,\n      xx,\n      yy;\n    if (t < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (t > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + t * C;\n      yy = y1 + t * D;\n    }\n    const dx = px - xx,\n      dy = py - yy;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  // full “is this tile allowed?” check\n  function isValid(x, y, w, h) {\n    // 1) each corner inside polygon\n    const corners = [{\n      x,\n      y\n    }, {\n      x: x + w,\n      y\n    }, {\n      x,\n      y: y + h\n    }, {\n      x: x + w,\n      y: y + h\n    }];\n    for (const c of corners) {\n      if (!pointInPoly(c.x, c.y, polygonPoints)) return false;\n    }\n    // 2) each corner ≥ margin from every edge\n    for (const c of corners) {\n      for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {\n        const p1 = polygonPoints[i],\n          p2 = polygonPoints[j];\n        if (ptSegDist(c.x, c.y, p1.x, p1.y, p2.x, p2.y) < margin) {\n          return false;\n        }\n      }\n    }\n    // 3) no overlap\n    for (const t of placements) {\n      if (!(x + w <= t.x || t.x + t.width <= x || y + h <= t.y || t.y + t.height <= y)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // --- 2) Prep scan bounds & tile sizes ---\n\n  // bounding‐box of your **polygon** (not the canvas)\n  const xs = polygonPoints.map(p => p.x);\n  const ys = polygonPoints.map(p => p.y);\n  const minXPoly = Math.min(...xs),\n    maxXPoly = Math.max(...xs);\n  const minYPoly = Math.min(...ys),\n    maxYPoly = Math.max(...ys);\n\n  // tile lengths sorted big → small\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const minLength = lengths[lengths.length - 1];\n\n  // result arrays\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // --- 3) Packing routines ---\n\n  // HORIZONTAL‑only strips (tileW tall)\n  function doHorizontal() {\n    for (let y = minYPoly + margin; y <= maxYPoly - margin - tileW + 1e-6; y += tileW) {\n      let x = minXPoly + margin;\n      while (x <= maxXPoly - margin - minLength + 1e-6) {\n        let placed = false;\n        for (const L of lengths) {\n          if (x + L <= maxXPoly - margin + 1e-6 && isValid(x, y, L, tileW)) {\n            placements.push({\n              x,\n              y,\n              width: L,\n              height: tileW,\n              length: L\n            });\n            counts[L]++;\n            x += L; // advance by the long side\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) {\n          // no tile fit here—bump x by the smallest tile length\n          x += minLength;\n        }\n      }\n    }\n  }\n\n  // VERTICAL‑only strips (tileW wide)\n  function doVertical() {\n    for (let x = minXPoly + margin; x <= maxXPoly - margin - tileW + 1e-6; x += tileW) {\n      let y = minYPoly + margin;\n      while (y <= maxYPoly - margin - minLength + 1e-6) {\n        let placed = false;\n        for (const L of lengths) {\n          if (y + L <= maxYPoly - margin + 1e-6 && isValid(x, y, tileW, L)) {\n            placements.push({\n              x,\n              y,\n              width: tileW,\n              height: L,\n              length: L\n            });\n            counts[L]++;\n            y += L;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) {\n          y += minLength;\n        }\n      }\n    }\n  }\n\n  // run selected modes\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\n  if (orientation === 'both' || orientation === 'vertical') doVertical();\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["optimizeLayout","polygonPoints","zoneW","zoneH","lengthsIn","tileW","margin","orientation","pointInPoly","x","y","vs","inside","i","j","length","xi","yi","xj","yj","intersect","ptSegDist","px","py","x1","y1","x2","y2","A","B","C","D","dot","len2","t","xx","yy","dx","dy","Math","sqrt","isValid","w","h","corners","c","p1","p2","placements","width","height","xs","map","p","ys","minXPoly","min","maxXPoly","max","minYPoly","maxYPoly","lengths","sort","a","b","minLength","counts","doHorizontal","placed","L","push","doVertical"],"sources":["c:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["// src/utils/optimizer.js\r\n\r\n// Greedy edge‑to‑edge packer that hugs your polygon + 207 mm clearance\r\nexport default function optimizeLayout(\r\n  polygonPoints,    // [{x,y},…] in meters\r\n  zoneW,            // bounding‐box W (m) – only for canvas size\r\n  zoneH,            // bounding‐box H (m)\r\n  lengthsIn,        // e.g. [4,2,1]\r\n  tileW,            // tile short side (m), e.g. 1.26\r\n  margin,           // clearance from walls (m), e.g. 0.207\r\n  orientation       // 'both' | 'horizontal' | 'vertical'\r\n) {\r\n  // --- 1) Helpers ---\r\n\r\n  // point‐in‐polygon (ray‐cast)\r\n  function pointInPoly(x, y, vs) {\r\n    let inside = false;\r\n    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\r\n      const xi = vs[i].x, yi = vs[i].y;\r\n      const xj = vs[j].x, yj = vs[j].y;\r\n      const intersect =\r\n        (yi > y) !== (yj > y) &&\r\n        x < ((xj - xi)*(y - yi))/(yj - yi) + xi;\r\n      if (intersect) inside = !inside;\r\n    }\r\n    return inside;\r\n  }\r\n\r\n  // distance from (px,py) to segment [(x1,y1)-(x2,y2)]\r\n  function ptSegDist(px, py, x1, y1, x2, y2) {\r\n    const A=px-x1, B=py-y1, C=x2-x1, D=y2-y1;\r\n    const dot = A*C + B*D, len2 = C*C + D*D;\r\n    let t = len2? dot/len2 : -1, xx, yy;\r\n    if (t < 0)      { xx = x1; yy = y1; }\r\n    else if (t > 1) { xx = x2; yy = y2; }\r\n    else {\r\n      xx = x1 + t*C;\r\n      yy = y1 + t*D;\r\n    }\r\n    const dx=px-xx, dy=py-yy;\r\n    return Math.sqrt(dx*dx + dy*dy);\r\n  }\r\n\r\n  // full “is this tile allowed?” check\r\n  function isValid(x, y, w, h) {\r\n    // 1) each corner inside polygon\r\n    const corners = [\r\n      {x,y}, {x:x+w, y}, {x, y:y+h}, {x:x+w, y:y+h}\r\n    ];\r\n    for (const c of corners) {\r\n      if (!pointInPoly(c.x, c.y, polygonPoints)) return false;\r\n    }\r\n    // 2) each corner ≥ margin from every edge\r\n    for (const c of corners) {\r\n      for (let i=0, j=polygonPoints.length-1; i<polygonPoints.length; j=i++){\r\n        const p1 = polygonPoints[i], p2 = polygonPoints[j];\r\n        if (ptSegDist(c.x, c.y, p1.x, p1.y, p2.x, p2.y) < margin) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    // 3) no overlap\r\n    for (const t of placements) {\r\n      if (!(\r\n        x + w <= t.x ||\r\n        t.x + t.width <= x ||\r\n        y + h <= t.y ||\r\n        t.y + t.height <= y\r\n      )) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // --- 2) Prep scan bounds & tile sizes ---\r\n\r\n  // bounding‐box of your **polygon** (not the canvas)\r\n  const xs = polygonPoints.map(p => p.x);\r\n  const ys = polygonPoints.map(p => p.y);\r\n  const minXPoly = Math.min(...xs), maxXPoly = Math.max(...xs);\r\n  const minYPoly = Math.min(...ys), maxYPoly = Math.max(...ys);\r\n\r\n  // tile lengths sorted big → small\r\n  const lengths = [...lengthsIn].sort((a,b) => b - a);\r\n  const minLength = lengths[lengths.length - 1];\r\n\r\n  // result arrays\r\n  const placements = [];\r\n  const counts = {4:0, 2:0, 1:0};\r\n\r\n  // --- 3) Packing routines ---\r\n\r\n  // HORIZONTAL‑only strips (tileW tall)\r\n  function doHorizontal() {\r\n    for (\r\n      let y = minYPoly + margin;\r\n      y <= maxYPoly - margin - tileW + 1e-6;\r\n      y += tileW\r\n    ) {\r\n      let x = minXPoly + margin;\r\n      while (\r\n        x <= maxXPoly - margin - minLength + 1e-6\r\n      ) {\r\n        let placed = false;\r\n        for (const L of lengths) {\r\n          if (\r\n            x + L <= maxXPoly - margin + 1e-6 &&\r\n            isValid(x, y, L, tileW)\r\n          ) {\r\n            placements.push({ x, y, width: L, height: tileW, length: L });\r\n            counts[L]++;\r\n            x += L;  // advance by the long side\r\n            placed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!placed) {\r\n          // no tile fit here—bump x by the smallest tile length\r\n          x += minLength;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // VERTICAL‑only strips (tileW wide)\r\n  function doVertical() {\r\n    for (\r\n      let x = minXPoly + margin;\r\n      x <= maxXPoly - margin - tileW + 1e-6;\r\n      x += tileW\r\n    ) {\r\n      let y = minYPoly + margin;\r\n      while (\r\n        y <= maxYPoly - margin - minLength + 1e-6\r\n      ) {\r\n        let placed = false;\r\n        for (const L of lengths) {\r\n          if (\r\n            y + L <= maxYPoly - margin + 1e-6 &&\r\n            isValid(x, y, tileW, L)\r\n          ) {\r\n            placements.push({ x, y, width: tileW, height: L, length: L });\r\n            counts[L]++;\r\n            y += L;\r\n            placed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!placed) {\r\n          y += minLength;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // run selected modes\r\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\r\n  if (orientation === 'both' || orientation === 'vertical')   doVertical();\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"AAAA;;AAEA;AACA,eAAe,SAASA,cAAcA,CACpCC,aAAa;AAAK;AAClBC,KAAK;AAAa;AAClBC,KAAK;AAAa;AAClBC,SAAS;AAAS;AAClBC,KAAK;AAAa;AAClBC,MAAM;AAAY;AAClBC,WAAW,CAAO;AAAA,EAClB;EACA;;EAEA;EACA,SAASC,WAAWA,CAACC,CAAC,EAAEC,CAAC,EAAEC,EAAE,EAAE;IAC7B,IAAIC,MAAM,GAAG,KAAK;IAClB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGH,EAAE,CAACI,MAAM,GAAG,CAAC,EAAEF,CAAC,GAAGF,EAAE,CAACI,MAAM,EAAED,CAAC,GAAGD,CAAC,EAAE,EAAE;MACzD,MAAMG,EAAE,GAAGL,EAAE,CAACE,CAAC,CAAC,CAACJ,CAAC;QAAEQ,EAAE,GAAGN,EAAE,CAACE,CAAC,CAAC,CAACH,CAAC;MAChC,MAAMQ,EAAE,GAAGP,EAAE,CAACG,CAAC,CAAC,CAACL,CAAC;QAAEU,EAAE,GAAGR,EAAE,CAACG,CAAC,CAAC,CAACJ,CAAC;MAChC,MAAMU,SAAS,GACZH,EAAE,GAAGP,CAAC,KAAOS,EAAE,GAAGT,CAAE,IACrBD,CAAC,GAAI,CAACS,EAAE,GAAGF,EAAE,KAAGN,CAAC,GAAGO,EAAE,CAAC,IAAGE,EAAE,GAAGF,EAAE,CAAC,GAAGD,EAAE;MACzC,IAAII,SAAS,EAAER,MAAM,GAAG,CAACA,MAAM;IACjC;IACA,OAAOA,MAAM;EACf;;EAEA;EACA,SAASS,SAASA,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE;IACzC,MAAMC,CAAC,GAACN,EAAE,GAACE,EAAE;MAAEK,CAAC,GAACN,EAAE,GAACE,EAAE;MAAEK,CAAC,GAACJ,EAAE,GAACF,EAAE;MAAEO,CAAC,GAACJ,EAAE,GAACF,EAAE;IACxC,MAAMO,GAAG,GAAGJ,CAAC,GAACE,CAAC,GAAGD,CAAC,GAACE,CAAC;MAAEE,IAAI,GAAGH,CAAC,GAACA,CAAC,GAAGC,CAAC,GAACA,CAAC;IACvC,IAAIG,CAAC,GAAGD,IAAI,GAAED,GAAG,GAACC,IAAI,GAAG,CAAC,CAAC;MAAEE,EAAE;MAAEC,EAAE;IACnC,IAAIF,CAAC,GAAG,CAAC,EAAO;MAAEC,EAAE,GAAGX,EAAE;MAAEY,EAAE,GAAGX,EAAE;IAAE,CAAC,MAChC,IAAIS,CAAC,GAAG,CAAC,EAAE;MAAEC,EAAE,GAAGT,EAAE;MAAEU,EAAE,GAAGT,EAAE;IAAE,CAAC,MAChC;MACHQ,EAAE,GAAGX,EAAE,GAAGU,CAAC,GAACJ,CAAC;MACbM,EAAE,GAAGX,EAAE,GAAGS,CAAC,GAACH,CAAC;IACf;IACA,MAAMM,EAAE,GAACf,EAAE,GAACa,EAAE;MAAEG,EAAE,GAACf,EAAE,GAACa,EAAE;IACxB,OAAOG,IAAI,CAACC,IAAI,CAACH,EAAE,GAACA,EAAE,GAAGC,EAAE,GAACA,EAAE,CAAC;EACjC;;EAEA;EACA,SAASG,OAAOA,CAAChC,CAAC,EAAEC,CAAC,EAAEgC,CAAC,EAAEC,CAAC,EAAE;IAC3B;IACA,MAAMC,OAAO,GAAG,CACd;MAACnC,CAAC;MAACC;IAAC,CAAC,EAAE;MAACD,CAAC,EAACA,CAAC,GAACiC,CAAC;MAAEhC;IAAC,CAAC,EAAE;MAACD,CAAC;MAAEC,CAAC,EAACA,CAAC,GAACiC;IAAC,CAAC,EAAE;MAAClC,CAAC,EAACA,CAAC,GAACiC,CAAC;MAAEhC,CAAC,EAACA,CAAC,GAACiC;IAAC,CAAC,CAC9C;IACD,KAAK,MAAME,CAAC,IAAID,OAAO,EAAE;MACvB,IAAI,CAACpC,WAAW,CAACqC,CAAC,CAACpC,CAAC,EAAEoC,CAAC,CAACnC,CAAC,EAAET,aAAa,CAAC,EAAE,OAAO,KAAK;IACzD;IACA;IACA,KAAK,MAAM4C,CAAC,IAAID,OAAO,EAAE;MACvB,KAAK,IAAI/B,CAAC,GAAC,CAAC,EAAEC,CAAC,GAACb,aAAa,CAACc,MAAM,GAAC,CAAC,EAAEF,CAAC,GAACZ,aAAa,CAACc,MAAM,EAAED,CAAC,GAACD,CAAC,EAAE,EAAC;QACpE,MAAMiC,EAAE,GAAG7C,aAAa,CAACY,CAAC,CAAC;UAAEkC,EAAE,GAAG9C,aAAa,CAACa,CAAC,CAAC;QAClD,IAAIO,SAAS,CAACwB,CAAC,CAACpC,CAAC,EAAEoC,CAAC,CAACnC,CAAC,EAAEoC,EAAE,CAACrC,CAAC,EAAEqC,EAAE,CAACpC,CAAC,EAAEqC,EAAE,CAACtC,CAAC,EAAEsC,EAAE,CAACrC,CAAC,CAAC,GAAGJ,MAAM,EAAE;UACxD,OAAO,KAAK;QACd;MACF;IACF;IACA;IACA,KAAK,MAAM4B,CAAC,IAAIc,UAAU,EAAE;MAC1B,IAAI,EACFvC,CAAC,GAAGiC,CAAC,IAAIR,CAAC,CAACzB,CAAC,IACZyB,CAAC,CAACzB,CAAC,GAAGyB,CAAC,CAACe,KAAK,IAAIxC,CAAC,IAClBC,CAAC,GAAGiC,CAAC,IAAIT,CAAC,CAACxB,CAAC,IACZwB,CAAC,CAACxB,CAAC,GAAGwB,CAAC,CAACgB,MAAM,IAAIxC,CAAC,CACpB,EAAE;QACD,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;;EAEA;;EAEA;EACA,MAAMyC,EAAE,GAAGlD,aAAa,CAACmD,GAAG,CAACC,CAAC,IAAIA,CAAC,CAAC5C,CAAC,CAAC;EACtC,MAAM6C,EAAE,GAAGrD,aAAa,CAACmD,GAAG,CAACC,CAAC,IAAIA,CAAC,CAAC3C,CAAC,CAAC;EACtC,MAAM6C,QAAQ,GAAGhB,IAAI,CAACiB,GAAG,CAAC,GAAGL,EAAE,CAAC;IAAEM,QAAQ,GAAGlB,IAAI,CAACmB,GAAG,CAAC,GAAGP,EAAE,CAAC;EAC5D,MAAMQ,QAAQ,GAAGpB,IAAI,CAACiB,GAAG,CAAC,GAAGF,EAAE,CAAC;IAAEM,QAAQ,GAAGrB,IAAI,CAACmB,GAAG,CAAC,GAAGJ,EAAE,CAAC;;EAE5D;EACA,MAAMO,OAAO,GAAG,CAAC,GAAGzD,SAAS,CAAC,CAAC0D,IAAI,CAAC,CAACC,CAAC,EAACC,CAAC,KAAKA,CAAC,GAAGD,CAAC,CAAC;EACnD,MAAME,SAAS,GAAGJ,OAAO,CAACA,OAAO,CAAC9C,MAAM,GAAG,CAAC,CAAC;;EAE7C;EACA,MAAMiC,UAAU,GAAG,EAAE;EACrB,MAAMkB,MAAM,GAAG;IAAC,CAAC,EAAC,CAAC;IAAE,CAAC,EAAC,CAAC;IAAE,CAAC,EAAC;EAAC,CAAC;;EAE9B;;EAEA;EACA,SAASC,YAAYA,CAAA,EAAG;IACtB,KACE,IAAIzD,CAAC,GAAGiD,QAAQ,GAAGrD,MAAM,EACzBI,CAAC,IAAIkD,QAAQ,GAAGtD,MAAM,GAAGD,KAAK,GAAG,IAAI,EACrCK,CAAC,IAAIL,KAAK,EACV;MACA,IAAII,CAAC,GAAG8C,QAAQ,GAAGjD,MAAM;MACzB,OACEG,CAAC,IAAIgD,QAAQ,GAAGnD,MAAM,GAAG2D,SAAS,GAAG,IAAI,EACzC;QACA,IAAIG,MAAM,GAAG,KAAK;QAClB,KAAK,MAAMC,CAAC,IAAIR,OAAO,EAAE;UACvB,IACEpD,CAAC,GAAG4D,CAAC,IAAIZ,QAAQ,GAAGnD,MAAM,GAAG,IAAI,IACjCmC,OAAO,CAAChC,CAAC,EAAEC,CAAC,EAAE2D,CAAC,EAAEhE,KAAK,CAAC,EACvB;YACA2C,UAAU,CAACsB,IAAI,CAAC;cAAE7D,CAAC;cAAEC,CAAC;cAAEuC,KAAK,EAAEoB,CAAC;cAAEnB,MAAM,EAAE7C,KAAK;cAAEU,MAAM,EAAEsD;YAAE,CAAC,CAAC;YAC7DH,MAAM,CAACG,CAAC,CAAC,EAAE;YACX5D,CAAC,IAAI4D,CAAC,CAAC,CAAE;YACTD,MAAM,GAAG,IAAI;YACb;UACF;QACF;QACA,IAAI,CAACA,MAAM,EAAE;UACX;UACA3D,CAAC,IAAIwD,SAAS;QAChB;MACF;IACF;EACF;;EAEA;EACA,SAASM,UAAUA,CAAA,EAAG;IACpB,KACE,IAAI9D,CAAC,GAAG8C,QAAQ,GAAGjD,MAAM,EACzBG,CAAC,IAAIgD,QAAQ,GAAGnD,MAAM,GAAGD,KAAK,GAAG,IAAI,EACrCI,CAAC,IAAIJ,KAAK,EACV;MACA,IAAIK,CAAC,GAAGiD,QAAQ,GAAGrD,MAAM;MACzB,OACEI,CAAC,IAAIkD,QAAQ,GAAGtD,MAAM,GAAG2D,SAAS,GAAG,IAAI,EACzC;QACA,IAAIG,MAAM,GAAG,KAAK;QAClB,KAAK,MAAMC,CAAC,IAAIR,OAAO,EAAE;UACvB,IACEnD,CAAC,GAAG2D,CAAC,IAAIT,QAAQ,GAAGtD,MAAM,GAAG,IAAI,IACjCmC,OAAO,CAAChC,CAAC,EAAEC,CAAC,EAAEL,KAAK,EAAEgE,CAAC,CAAC,EACvB;YACArB,UAAU,CAACsB,IAAI,CAAC;cAAE7D,CAAC;cAAEC,CAAC;cAAEuC,KAAK,EAAE5C,KAAK;cAAE6C,MAAM,EAAEmB,CAAC;cAAEtD,MAAM,EAAEsD;YAAE,CAAC,CAAC;YAC7DH,MAAM,CAACG,CAAC,CAAC,EAAE;YACX3D,CAAC,IAAI2D,CAAC;YACND,MAAM,GAAG,IAAI;YACb;UACF;QACF;QACA,IAAI,CAACA,MAAM,EAAE;UACX1D,CAAC,IAAIuD,SAAS;QAChB;MACF;IACF;EACF;;EAEA;EACA,IAAI1D,WAAW,KAAK,MAAM,IAAIA,WAAW,KAAK,YAAY,EAAE4D,YAAY,CAAC,CAAC;EAC1E,IAAI5D,WAAW,KAAK,MAAM,IAAIA,WAAW,KAAK,UAAU,EAAIgE,UAAU,CAAC,CAAC;EAExE,OAAO;IAAEvB,UAAU;IAAEkB;EAAO,CAAC;AAC/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}