{"ast":null,"code":"// src/utils/optimizer.js\n\nimport * as turf from '@turf/turf';\n\n/**\r\n * @param {Array<{x:number,y:number}>} polygonPoints  – your room polygon, in meters\r\n * @param {number} zoneW   – overall bounding‐box width (m)\r\n * @param {number} zoneH   – overall bounding‐box height (m)\r\n * @param {number[]} lengthsIn – tile lengths to try, e.g. [4,2,1]\r\n * @param {number} tileW   – tile short side width (m), e.g. 1.26\r\n * @param {number} margin  – margin from walls (m), e.g. 0.207\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n *\r\n * @returns {{ placements: Array<{x,y,width,height,length}>, counts: {4:number,2:number,1:number} }}\r\n */\nexport default function optimizeLayout(polygonPoints, zoneW, zoneH, lengthsIn, tileW, margin, orientation) {\n  // --- 1) Build and inward‐buffer the room polygon ---\n  const coords = polygonPoints.map(p => [p.x, p.y]);\n  coords.push(coords[0]); // close ring\n  const roomPoly = turf.polygon([coords]);\n  // shrink it by 'margin' meters\n  const inner = turf.buffer(roomPoly, -margin, {\n    units: 'meters'\n  });\n  if (!inner || !inner.geometry) {\n    // too small for any tile\n    return {\n      placements: [],\n      counts: {\n        4: 0,\n        2: 0,\n        1: 0\n      }\n    };\n  }\n\n  // bounding box of the allowed region\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\n\n  // sort lengths descending to try big→small\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // helper: test if a candidate tile rectangle lies completely inside 'inner'\n  function fitsInInner(x, y, w, h) {\n    const rect = turf.polygon([[[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]]]);\n    // Turf's booleanContains(A,B) is true if A completely contains B\n    return turf.booleanContains(inner, rect);\n  }\n\n  // horizontal‐long packing\n  function doHorizontal() {\n    for (let y = minY; y <= maxY - tileW + 1e-6; y += tileW) {\n      let x = minX;\n      // walk across this horizontal strip\n      while (x <= maxX - lengths[lengths.length - 1] + 1e-6) {\n        let placed = false;\n        for (const L of lengths) {\n          if (x + L <= maxX + 1e-6 && fitsInInner(x, y, L, tileW)) {\n            placements.push({\n              x,\n              y,\n              width: L,\n              height: tileW,\n              length: L\n            });\n            counts[L]++;\n            x += L; // advance by the length we placed\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) {\n          // no size fit here → skip ahead by one strip\n          x += tileW;\n        }\n      }\n    }\n  }\n\n  // vertical‐long packing\n  function doVertical() {\n    for (let x = minX; x <= maxX - tileW + 1e-6; x += tileW) {\n      let y = minY;\n      while (y <= maxY - lengths[lengths.length - 1] + 1e-6) {\n        let placed = false;\n        for (const L of lengths) {\n          if (y + L <= maxY + 1e-6 && fitsInInner(x, y, tileW, L)) {\n            placements.push({\n              x,\n              y,\n              width: tileW,\n              height: L,\n              length: L\n            });\n            counts[L]++;\n            y += L;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) {\n          y += tileW;\n        }\n      }\n    }\n  }\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\n  if (orientation === 'both' || orientation === 'vertical') doVertical();\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["turf","optimizeLayout","polygonPoints","zoneW","zoneH","lengthsIn","tileW","margin","orientation","coords","map","p","x","y","push","roomPoly","polygon","inner","buffer","units","geometry","placements","counts","minX","minY","maxX","maxY","bbox","lengths","sort","a","b","fitsInInner","w","h","rect","booleanContains","doHorizontal","length","placed","L","width","height","doVertical"],"sources":["c:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["// src/utils/optimizer.js\r\n\r\nimport * as turf from '@turf/turf';\r\n\r\n/**\r\n * @param {Array<{x:number,y:number}>} polygonPoints  – your room polygon, in meters\r\n * @param {number} zoneW   – overall bounding‐box width (m)\r\n * @param {number} zoneH   – overall bounding‐box height (m)\r\n * @param {number[]} lengthsIn – tile lengths to try, e.g. [4,2,1]\r\n * @param {number} tileW   – tile short side width (m), e.g. 1.26\r\n * @param {number} margin  – margin from walls (m), e.g. 0.207\r\n * @param {'both'|'horizontal'|'vertical'} orientation\r\n *\r\n * @returns {{ placements: Array<{x,y,width,height,length}>, counts: {4:number,2:number,1:number} }}\r\n */\r\nexport default function optimizeLayout(\r\n  polygonPoints,\r\n  zoneW,\r\n  zoneH,\r\n  lengthsIn,\r\n  tileW,\r\n  margin,\r\n  orientation\r\n) {\r\n  // --- 1) Build and inward‐buffer the room polygon ---\r\n  const coords = polygonPoints.map(p => [p.x, p.y]);\r\n  coords.push(coords[0]); // close ring\r\n  const roomPoly = turf.polygon([coords]);\r\n  // shrink it by 'margin' meters\r\n  const inner = turf.buffer(roomPoly, -margin, { units: 'meters' });\r\n  if (!inner || !inner.geometry) {\r\n    // too small for any tile\r\n    return { placements: [], counts: {4:0,2:0,1:0} };\r\n  }\r\n\r\n  // bounding box of the allowed region\r\n  const [minX, minY, maxX, maxY] = turf.bbox(inner);\r\n\r\n  // sort lengths descending to try big→small\r\n  const lengths = [...lengthsIn].sort((a,b) => b - a);\r\n\r\n  const placements = [];\r\n  const counts = {4:0,2:0,1:0};\r\n\r\n  // helper: test if a candidate tile rectangle lies completely inside 'inner'\r\n  function fitsInInner(x, y, w, h) {\r\n    const rect = turf.polygon([[\r\n      [x,     y],\r\n      [x + w, y],\r\n      [x + w, y + h],\r\n      [x,     y + h],\r\n      [x,     y]\r\n    ]]);\r\n    // Turf's booleanContains(A,B) is true if A completely contains B\r\n    return turf.booleanContains(inner, rect);\r\n  }\r\n\r\n  // horizontal‐long packing\r\n  function doHorizontal() {\r\n    for (let y = minY; y <= maxY - tileW + 1e-6; y += tileW) {\r\n      let x = minX;\r\n      // walk across this horizontal strip\r\n      while (x <= maxX - lengths[lengths.length - 1] + 1e-6) {\r\n        let placed = false;\r\n        for (const L of lengths) {\r\n          if (x + L <= maxX + 1e-6 && fitsInInner(x, y, L, tileW)) {\r\n            placements.push({ x, y, width: L, height: tileW, length: L });\r\n            counts[L]++;\r\n            x += L;       // advance by the length we placed\r\n            placed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!placed) {\r\n          // no size fit here → skip ahead by one strip\r\n          x += tileW;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // vertical‐long packing\r\n  function doVertical() {\r\n    for (let x = minX; x <= maxX - tileW + 1e-6; x += tileW) {\r\n      let y = minY;\r\n      while (y <= maxY - lengths[lengths.length - 1] + 1e-6) {\r\n        let placed = false;\r\n        for (const L of lengths) {\r\n          if (y + L <= maxY + 1e-6 && fitsInInner(x, y, tileW, L)) {\r\n            placements.push({ x, y, width: tileW, height: L, length: L });\r\n            counts[L]++;\r\n            y += L;\r\n            placed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!placed) {\r\n          y += tileW;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (orientation === 'both' || orientation === 'horizontal') doHorizontal();\r\n  if (orientation === 'both' || orientation === 'vertical')   doVertical();\r\n\r\n  return { placements, counts };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}