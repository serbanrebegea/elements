{"ast":null,"code":"/**\r\n * Packs 4 m→2 m→1 m tiles edge‑to‑edge with exactly `margin` clearance.\r\n *\r\n * @param {{x,y}[]} points       – polygon vertices\r\n * @param {number[]} lengthsIn   – e.g. [4,2,1]\r\n * @param {number} tileW         – tile short side\r\n * @param {number} margin        – clearance\r\n * @param {'both'|'horizontal'|'vertical'} orient\r\n * @param {'bottom-left'|'bottom-right'|'top-right'|'top-left'} corner\r\n */\nexport default function optimizeLayout(points, lengthsIn, tileW, margin, orient, corner) {\n  // point‑in‑poly (ray‑cast)\n  function pip(x, y, vs) {\n    let inside = false;\n    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n      const xi = vs[i].x,\n        yi = vs[i].y;\n      const xj = vs[j].x,\n        yj = vs[j].y;\n      const inter = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n      if (inter) inside = !inside;\n    }\n    return inside;\n  }\n  // point‑to‑segment distance\n  function psd(px, py, x1, y1, x2, y2) {\n    const A = px - x1,\n      B = py - y1,\n      C = x2 - x1,\n      D = y2 - y1;\n    const dot = A * C + B * D,\n      len2 = C * C + D * D;\n    let t = len2 ? dot / len2 : -1,\n      xx,\n      yy;\n    if (t < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (t > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + t * C;\n      yy = y1 + t * D;\n    }\n    const dx = px - xx,\n      dy = py - yy;\n    return Math.hypot(dx, dy);\n  }\n  const placements = [];\n  const counts = {\n    4: 0,\n    2: 0,\n    1: 0\n  };\n\n  // valid if inside, ≥margin, no overlap\n  function valid(x, y, w, h) {\n    const corners = [{\n      x,\n      y\n    }, {\n      x: x + w,\n      y\n    }, {\n      x,\n      y: y + h\n    }, {\n      x: x + w,\n      y: y + h\n    }];\n    for (const c of corners) {\n      if (!pip(c.x, c.y, points)) return false;\n    }\n    for (const c of corners) {\n      for (let i = 0, j = points.length - 1; i < points.length; j = i++) {\n        const a = points[i],\n          b = points[j];\n        if (psd(c.x, c.y, a.x, a.y, b.x, b.y) < margin) return false;\n      }\n    }\n    for (const t of placements) {\n      if (!(x + w <= t.x || t.x + t.width <= x || y + h <= t.y || t.y + t.height <= y)) return false;\n    }\n    return true;\n  }\n\n  // bounds\n  const xs = points.map(p => p.x),\n    ys = points.map(p => p.y);\n  const minX = Math.min(...xs),\n    maxX = Math.max(...xs);\n  const minY = Math.min(...ys),\n    maxY = Math.max(...ys);\n\n  // direction from corner\n  const map = {\n    'bottom-left': {\n      dx: +1,\n      dy: +1\n    },\n    'bottom-right': {\n      dx: -1,\n      dy: +1\n    },\n    'top-right': {\n      dx: -1,\n      dy: -1\n    },\n    'top-left': {\n      dx: +1,\n      dy: -1\n    }\n  }[corner];\n  const {\n    dx,\n    dy\n  } = map;\n  const lengths = [...lengthsIn].sort((a, b) => b - a);\n  const minL = lengths[lengths.length - 1];\n  const xStart = dx > 0 ? minX + margin : maxX - margin;\n  const xEnd = dx > 0 ? maxX - margin - minL : minX + margin + minL;\n  const yStart = dy > 0 ? minY + margin : maxY - margin - tileW;\n  const yEnd = dy > 0 ? maxY - margin - tileW : minY + margin;\n  const xStep = minL * dx;\n  const yStep = tileW * dy;\n\n  // horizontal scan\n  function hor() {\n    for (let y = yStart; dy > 0 ? y <= yEnd : y >= yEnd; y += yStep) {\n      let x = xStart;\n      while (dx > 0 ? x <= xEnd : x >= xEnd) {\n        let placed = false;\n        for (const L of lengths) {\n          const px = dx > 0 ? x : x - L;\n          if (valid(px, y, L, tileW)) {\n            placements.push({\n              x: px,\n              y,\n              width: L,\n              height: tileW,\n              length: L\n            });\n            counts[L]++;\n            x += L * dx;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) x += xStep;\n      }\n    }\n  }\n\n  // vertical scan\n  function ver() {\n    for (let x = xStart; dx > 0 ? x <= xEnd : x >= xEnd; x += yStep) {\n      let y = yStart;\n      while (dy > 0 ? y <= yEnd : y >= yEnd) {\n        let placed = false;\n        for (const L of lengths) {\n          const py = dy > 0 ? y : y - L;\n          if (valid(x, py, tileW, L)) {\n            placements.push({\n              x,\n              y: py,\n              width: tileW,\n              height: L,\n              length: L\n            });\n            counts[L]++;\n            y += L * dy;\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) y += yStep;\n      }\n    }\n  }\n  if (orient === 'both' || orient === 'horizontal') hor();\n  if (orient === 'both' || orient === 'vertical') ver();\n  return {\n    placements,\n    counts\n  };\n}","map":{"version":3,"names":["optimizeLayout","points","lengthsIn","tileW","margin","orient","corner","pip","x","y","vs","inside","i","j","length","xi","yi","xj","yj","inter","psd","px","py","x1","y1","x2","y2","A","B","C","D","dot","len2","t","xx","yy","dx","dy","Math","hypot","placements","counts","valid","w","h","corners","c","a","b","width","height","xs","map","p","ys","minX","min","maxX","max","minY","maxY","lengths","sort","minL","xStart","xEnd","yStart","yEnd","xStep","yStep","hor","placed","L","push","ver"],"sources":["c:/New folder (2)/src/utils/optimizer.js"],"sourcesContent":["/**\r\n * Packs 4 m→2 m→1 m tiles edge‑to‑edge with exactly `margin` clearance.\r\n *\r\n * @param {{x,y}[]} points       – polygon vertices\r\n * @param {number[]} lengthsIn   – e.g. [4,2,1]\r\n * @param {number} tileW         – tile short side\r\n * @param {number} margin        – clearance\r\n * @param {'both'|'horizontal'|'vertical'} orient\r\n * @param {'bottom-left'|'bottom-right'|'top-right'|'top-left'} corner\r\n */\r\nexport default function optimizeLayout(\r\n  points, lengthsIn, tileW, margin, orient, corner\r\n) {\r\n  // point‑in‑poly (ray‑cast)\r\n  function pip(x,y,vs) {\r\n    let inside=false;\r\n    for(let i=0,j=vs.length-1;i<vs.length;j=i++){\r\n      const xi=vs[i].x, yi=vs[i].y;\r\n      const xj=vs[j].x, yj=vs[j].y;\r\n      const inter = (yi>y)!==(yj>y)\r\n        && x < (xj-xi)*(y-yi)/(yj-yi)+xi;\r\n      if(inter) inside=!inside;\r\n    }\r\n    return inside;\r\n  }\r\n  // point‑to‑segment distance\r\n  function psd(px,py,x1,y1,x2,y2){\r\n    const A=px-x1, B=py-y1, C=x2-x1, D=y2-y1;\r\n    const dot=A*C+B*D, len2=C*C+D*D;\r\n    let t=len2?dot/len2:-1, xx,yy;\r\n    if(t<0){ xx=x1; yy=y1; }\r\n    else if(t>1){ xx=x2; yy=y2; }\r\n    else{ xx=x1+t*C; yy=y1+t*D; }\r\n    const dx=px-xx, dy=py-yy;\r\n    return Math.hypot(dx,dy);\r\n  }\r\n\r\n  const placements = [];\r\n  const counts = {4:0,2:0,1:0};\r\n\r\n  // valid if inside, ≥margin, no overlap\r\n  function valid(x,y,w,h){\r\n    const corners=[\r\n      {x,y},{x:x+w,y},\r\n      {x,y:y+h},{x:x+w,y:y+h}\r\n    ];\r\n    for(const c of corners){\r\n      if(!pip(c.x,c.y,points)) return false;\r\n    }\r\n    for(const c of corners){\r\n      for(let i=0,j=points.length-1;i<points.length;j=i++){\r\n        const a=points[i], b=points[j];\r\n        if(psd(c.x,c.y,a.x,a.y,b.x,b.y)<margin) return false;\r\n      }\r\n    }\r\n    for(const t of placements){\r\n      if(!(\r\n        x+w<=t.x ||\r\n        t.x+t.width<=x ||\r\n        y+h<=t.y ||\r\n        t.y+t.height<=y\r\n      )) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // bounds\r\n  const xs=points.map(p=>p.x), ys=points.map(p=>p.y);\r\n  const minX=Math.min(...xs), maxX=Math.max(...xs);\r\n  const minY=Math.min(...ys), maxY=Math.max(...ys);\r\n\r\n  // direction from corner\r\n  const map={\r\n    'bottom-left':  {dx:+1, dy:+1},\r\n    'bottom-right': {dx:-1, dy:+1},\r\n    'top-right':    {dx:-1, dy:-1},\r\n    'top-left':     {dx:+1, dy:-1}\r\n  }[corner];\r\n  const {dx,dy}=map;\r\n\r\n  const lengths=[...lengthsIn].sort((a,b)=>b-a);\r\n  const minL=lengths[lengths.length-1];\r\n\r\n  const xStart = dx>0? minX+margin : maxX-margin;\r\n  const xEnd   = dx>0? maxX-margin-minL : minX+margin+minL;\r\n  const yStart = dy>0? minY+margin : maxY-margin-tileW;\r\n  const yEnd   = dy>0? maxY-margin-tileW : minY+margin;\r\n\r\n  const xStep = minL * dx;\r\n  const yStep = tileW * dy;\r\n\r\n  // horizontal scan\r\n  function hor(){\r\n    for(let y=yStart; (dy>0?y<=yEnd:y>=yEnd); y+=yStep){\r\n      let x=xStart;\r\n      while(dx>0?x<=xEnd:x>=xEnd){\r\n        let placed=false;\r\n        for(const L of lengths){\r\n          const px = dx>0? x : x-L;\r\n          if(valid(px,y,L,tileW)){\r\n            placements.push({x:px,y,width:L,height:tileW,length:L});\r\n            counts[L]++; x+=L*dx; placed=true; break;\r\n          }\r\n        }\r\n        if(!placed) x+=xStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  // vertical scan\r\n  function ver(){\r\n    for(let x=xStart; (dx>0?x<=xEnd:x>=xEnd); x+=yStep){\r\n      let y=yStart;\r\n      while(dy>0?y<=yEnd:y>=yEnd){\r\n        let placed=false;\r\n        for(const L of lengths){\r\n          const py = dy>0? y : y-L;\r\n          if(valid(x,py,tileW,L)){\r\n            placements.push({x,y:py,width:tileW,height:L,length:L});\r\n            counts[L]++; y+=L*dy; placed=true; break;\r\n          }\r\n        }\r\n        if(!placed) y+=yStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  if(orient==='both'||orient==='horizontal') hor();\r\n  if(orient==='both'||orient==='vertical')   ver();\r\n\r\n  return {placements,counts};\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}